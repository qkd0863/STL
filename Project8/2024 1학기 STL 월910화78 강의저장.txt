


====================================================================================================
FileName.cpp, 저장시간: 2024-03-05 화요일 오전 12:52:40 
====================================================================================================
#include "save.h"

#include <iostream>
#include <chrono>
#include <vector>
#include <fstream>

using namespace std;
void save(string_view fileName);

int main()
{


	save("FileName.cpp");
}



void save(string_view fileName)
{
	//fileName을 읽을 파일로 연다
	ifstream in{ fileName.data() };
	if (not in)
	{
		cout << fileName << " - 파일 열기 실패" << endl;
		exit(0);
	}

	//저장한 파일을 덧붙여 쓰기모드로 연다
	ofstream out("2024 1학기 STL 월910화78 강의저장.txt", ios::app);

	//저장한 시간을 기록한다
	out << endl << endl << endl;
	auto now = chrono::system_clock::now();	//epoch로 부터 증가한 tick
	auto time = chrono::system_clock::to_time_t(now);	//UTC 시간으로 변환
	auto lt = localtime(&time); //현지 시간으로 변환

	auto old = out.imbue(locale("ko_KR"));
	//날짜를 내 마음대로 출력한다
	out << "====================================================================================================" << endl;
	out << fileName << put_time(lt, ", 저장시간: %x %A %X ") << endl;
	out << "====================================================================================================" << endl;
	out.imbue(old);

	//읽을 파일의 내용을 모두 읽어 쓸 파일에 덧붙여 쓴다
	//STL 자료구조와 알고리즘을 이용해 본다, 좋은 코딩은 아니다
	vector<char> v{ istreambuf_iterator<char>{in},{} };
	copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});

	/*for (char c : v)
		out << c;*/

}




====================================================================================================
FileName.cpp, 저장시간: 2024-03-05 화요일 오전 12:53:49 
====================================================================================================
#include "save.h"


int main()
{


	save("FileName.cpp");
}






====================================================================================================
FileName.cpp, 저장시간: 2024-03-18 월요일 오후 3:43:09 
====================================================================================================
#include "save.h"
#include <random>
#include <format>
#include <print>
#include <array>
#include <numeric>


//문제 파일 "int100개를메모리그대로저장.txt"에
// int값 100개가 wrtie 함수를 사용하여 기록되어 있다
// 파일은 binary 모드로 열어 기록하였다
// 파일에 기록된 int값 100개를 메모리로 읽어온 후 
// 화면에 출력하라


default_random_engine dre;
uniform_int_distribution<int> uidChar{ 'a','z' };
uniform_int_distribution uidNum{ 1,99999 };

class Dog
{
	char c{ (char)uidChar(dre) };
	int num{ uidNum(dre) };
public:
	Dog()
	{
		//cout << "디폴트 생성" << endl;
	}
	friend ostream& operator<<(ostream& os, const Dog& dog)
	{
		return os << "글자:" << dog.c << ", 숫자" << dog.num;
	}
};



int main()
{
	array<Dog, 100> dogs;		//초기화 안해도 디폴트 생성됨


	// 문제 dogs를 binary mode/write 로 파일에 기록하라
	// 기록된 파일을 읽어서 num값이 가장 큰 dog를 찾아 화면에 출력하라

	ofstream out{ "Dog.txt",ios::binary };
	out.write((const char*)dogs.data(), sizeof(Dog) * 100);

	for (Dog dog : dogs)
		cout << dog << endl;

	cout << endl << endl;


	array<Dog, 100> dogs_read;

	ifstream in{ "Dog.txt",ios::binary };
	if (not in)
	{
		cout << "파일열기 실패";
		exit(0);
	}

	in.read((char*)dogs_read.data(), sizeof(Dog) * 100);
	for (Dog dog : dogs_read)
		cout << dog << endl;


	//auto pos = max_element(dogs_read.begin(), dogs_read.end());
	//cout << "최댓값:" << *pos << endl;



	save("FileName.cpp");
}


====================================================================================================
FileName.cpp, 저장시간: 2024-03-18 월요일 오후 3:49:11 
====================================================================================================
#include "save.h"
#include <random>
#include <format>
#include <print>
#include <array>
#include <numeric>


//문제 파일 "int100개를메모리그대로저장.txt"에
// int값 100개가 wrtie 함수를 사용하여 기록되어 있다
// 파일은 binary 모드로 열어 기록하였다
// 파일에 기록된 int값 100개를 메모리로 읽어온 후 
// 화면에 출력하라


default_random_engine dre;
uniform_int_distribution<int> uidChar{ 'a','z' };
uniform_int_distribution uidNum{ 1,99999 };

class Dog
{
	char c{ (char)uidChar(dre) };
	int num{ uidNum(dre) };
public:
	Dog()
	{
		//cout << "디폴트 생성" << endl;
	}
	friend ostream& operator<<(ostream& os, const Dog& dog)
	{
		return os << "글자:" << dog.c << ", 숫자" << dog.num;
	}
};



int main()
{
	array<Dog, 100> dogs;		//초기화 안해도 디폴트 생성됨


	// 문제 dogs를 binary mode/write 로 파일에 기록하라
	// 기록된 파일을 읽어서 num값이 가장 큰 dog를 찾아 화면에 출력하라

	ofstream out{ "Dog.txt",ios::binary };
	out.write((const char*)dogs.data(), sizeof(Dog) * 100);

	for (Dog dog : dogs)
		cout << dog << endl;

	cout << endl << endl;


	array<Dog, 100> dogs_read;

	
	for (Dog dog : dogs_read)
		cout << dog << endl;


	//auto pos = max_element(dogs_read.begin(), dogs_read.end());
	//cout << "최댓값:" << *pos << endl;



	save("FileName.cpp");
}


====================================================================================================
FileName.cpp, 저장시간: 2024-03-18 월요일 오후 4:06:22 
====================================================================================================
#include "save.h"
#include <random>
#include <format>
#include <print>
#include <array>
#include <numeric>


//문제 파일 "int100개를메모리그대로저장.txt"에
// int값 100개가 wrtie 함수를 사용하여 기록되어 있다
// 파일은 binary 모드로 열어 기록하였다
// 파일에 기록된 int값 100개를 메모리로 읽어온 후 
// 화면에 출력하라


default_random_engine dre;
uniform_int_distribution<int> uidChar{ 'a','z' };
uniform_int_distribution uidNum{ 1,99999 };

class Dog
{
	char c{ (char)uidChar(dre) };
	int num{ uidNum(dre) };
public:
	Dog()
	{
		//cout << "디폴트 생성" << endl;
	}
	friend ostream& operator<<(ostream& os, const Dog& dog)
	{
		return os << "글자:" << dog.c << ", 숫자" << dog.num;
	}
};



int main()
{
	array<Dog, 100> dogs;		//초기화 안해도 디폴트 생성됨


	// 문제 dogs를 binary mode/write 로 파일에 기록하라
	// 기록된 파일을 읽어서 num값이 가장 큰 dog를 찾아 화면에 출력하라

	ofstream out{ "Dog.txt",ios::binary };
	out.write((const char*)dogs.data(), sizeof(Dog) * 100);

	for (Dog dog : dogs)
		cout << dog << endl;

	cout << endl << endl;


	array<Dog, 100> dogs_read;

	ifstream in{ "Dog.txt",ios::binary };
	if (not in)
	{
		cout << "파일열기 실패";
		exit(0);
	}

	in.read((char*)dogs_read.data(), sizeof(Dog) * 100);
	for (Dog dog : dogs_read)
		cout << dog << endl;


	//auto pos = max_element(dogs_read.begin(), dogs_read.end());
	//cout << "최댓값:" << *pos << endl;



	save("FileName.cpp");
}


====================================================================================================
FileName.cpp, 저장시간: 2024-03-18 월요일 오후 6:36:10 
====================================================================================================
#include "save.h"
#include <random>
#include <format>
#include <print>
#include <array>
#include <numeric>


//-----------------------------------------------------------------
// 2024.03.018 1학기 stl 화 5~6 목 5~6                       (3주 1)
// 
//-----------------------------------------------------------------



//문제 파일 "int100개를메모리그대로저장.txt"에
// int값 100개가 wrtie 함수를 사용하여 기록되어 있다
// 파일은 binary 모드로 열어 기록하였다
// 파일에 기록된 int값 100개를 메모리로 읽어온 후 
// 화면에 출력하라


default_random_engine dre;
uniform_int_distribution<int> uidChar{ 'a','z' };
uniform_int_distribution uidNum{ 1,99999 };


// 문제 "Dog.txt" 파일은 binary 모드로 기록되었다
// 여기에는 몇 개인지 모르는 class Dog 객체를 write 함수를 사용하여 기록하였다
// class Dog의 멤버는 다음과 같다
// 파일을 읽어 num값이 가장 큰 Dog 객체를 화면에 출력하라

class Dog
{
	char c;
	int num;
public:
	int getN()const 
	{
		return num;
	}
	void show()const
	{
		cout << "char - " << c << ", num - " << num << endl;
	}
	friend istream& operator>>(istream& is, Dog& dog)
	{
		return is.read((char*)&dog, sizeof(Dog));
	}
	
};

int main()
{
	

	ifstream in{ "Dog.txt",ios::binary };
	if (not in)
	{
		cout << "파일 열기 실패" << endl;
		exit(0);
	}
	

	//마지막 Dog   char - i, num - 38857
	//가장 큰 Dog:char - y, num - 99646

	array<Dog, 100> dogs_read;
	in.read((char*)dogs_read.data(), sizeof(Dog) * 100);
	for (Dog d : dogs_read)
		d.show();
	
	
	auto pos=max_element(dogs_read.begin(), dogs_read.end(), [](const Dog& a, const Dog& b) {return a.getN() < b.getN(); });
	//begin=a end=b, b-a == 800  -> a의 type이 뭐야? -> a의 type으로 나눠서 개수를 알아낸다
	
	cout << "num 값이 가장 큰 Dog:";
	pos->show();





	save("FileName.cpp");
}




//Dog dog;
//int count{};
//while (in >> dog)
//count++;
//cout << "개수:" << count << endl;
//dog.show();


// dogs.data() == 시작주소


====================================================================================================
FileName.cpp, 저장시간: 2024-03-18 월요일 오후 6:52:25 
====================================================================================================
#include "save.h"
#include <random>
#include <format>
#include <print>
#include <array>
#include <numeric>


//-----------------------------------------------------------------
// 2024.03.018 1학기 stl 화 5~6 목 5~6                       (3주 1)
// 
//-----------------------------------------------------------------



//문제 파일 "int100개를메모리그대로저장.txt"에
// int값 100개가 wrtie 함수를 사용하여 기록되어 있다
// 파일은 binary 모드로 열어 기록하였다
// 파일에 기록된 int값 100개를 메모리로 읽어온 후 
// 화면에 출력하라


default_random_engine dre;
uniform_int_distribution<int> uidChar{ 'a','z' };
uniform_int_distribution uidNum{ 1,99999 };


// 문제 "Dog.txt" 파일은 binary 모드로 기록되었다
// 여기에는 몇 개인지 모르는 class Dog 객체를 write 함수를 사용하여 기록하였다
// class Dog의 멤버는 다음과 같다
// 파일을 읽어 num값이 1000미만인 Dog 객체를 화면에 출력하라

class Dog
{
	char c;
	int num;
public:
	int getN()const 
	{
		return num;
	}
	void show()const
	{
		cout << "char - " << c << ", num - " << num << endl;
	}
	friend istream& operator>>(istream& is, Dog& dog)
	{
		return is.read((char*)&dog, sizeof(Dog));
	}
	
};

int main()
{
	

	ifstream in{ "Dog.txt",ios::binary };
	if (not in)
	{
		cout << "파일 열기 실패" << endl;
		exit(0);
	}
	

	//마지막 Dog   char - i, num - 38857
	//가장 큰 Dog:char - y, num - 99646

	array<Dog, 100> dogs_read;
	in.read((char*)dogs_read.data(), sizeof(Dog) * 100);
	for (Dog d : dogs_read)
		d.show();
	
	
	auto pos=max_element(dogs_read.begin(), dogs_read.end(), [](const Dog& a, const Dog& b) {return a.getN() < b.getN(); });
	//begin=a end=b, b-a == 800  -> a의 type이 뭐야? -> a의 type으로 나눠서 개수를 알아낸다
	
	cout << "num 값이 가장 큰 Dog:";
	pos->show();

	auto p = count_if(dogs_read.begin(), dogs_read.end(), [](const Dog& dog) {return 1000 > dog.getN(); }); //숫자는 왼쪽에 쓰자
	cout << p;

	int cnt{};
	for (Dog d : dogs_read)
		if (d.getN() < 1000)
			cnt++;
		
	cout << "num 값이 1000 미만인 개수:" << cnt << endl;





	save("FileName.cpp");
}




//Dog dog;
//int count{};
//while (in >> dog)
//count++;
//cout << "개수:" << count << endl;
//dog.show();


// dogs.data() == 시작주소


====================================================================================================
FileName.cpp, 저장시간: 2024-03-19 화요일 오후 4:09:03 
====================================================================================================
#include "save.h"
#include <string>
#include <array>
//-----------------------------------------------------------------
// 2024.03.19 1학기 stl 화 5~6 목 5~6                       (3주 2)
// 
// 실행 파일의 메모리 영역 - stack code data free store(heap)
//-----------------------------------------------------------------

void f()
{
	int num{123};

	cout << "나는 함수 f 입니다" << endl;
	cout << "f()의 변수 num " << addressof(num) << endl;
}



int gnum{};
string s{"전역 스트링"};






int main()
{
	string s{ "메모리 관찰" };
	cout << "지역 객체 string - " << addressof(s) << endl;

	array<int, 10> a;
	cout << "지역 객체 array<int,10> " << endl;
	for (int i = 0; i < a.size(); ++i)
		cout << "a[" << i << "]" << addressof(a[i]) << endl;

	f();


	cout << "전역 string - " << ::s << endl;
	cout << addressof(::s) << endl;
	cout << "전역 int - " << endl;
	cout << addressof(gnum) << endl;

	cout << endl << endl;
	cout << "함수가 기록되는 메모리 영역 - CODE segment, TEXT segment" << endl;
	cout << "main() - " << addressof(main) << endl;
	cout << "f() - " << addressof(f) << endl;
	cout << "save() - " << addressof(save) << endl;


	string* p = new string[2]{ "동적할당한 string1","동적할당한 string2" };
	cout << endl << endl;

	cout << p[0]<< " - " << addressof(p[0]) << endl;
	cout << p[1]<< " - " << addressof(p[1]) << endl;


	save("FileName.cpp");
}



// 실제로 실행해보면 메모리 위치가 다르다


====================================================================================================
FileName.cpp, 저장시간: 2024-03-19 화요일 오후 5:21:13 
====================================================================================================
#include "save.h"
#include <string>
#include <array>
//-----------------------------------------------------------------
// 2024.03.19 1학기 stl 화 5~6 목 5~6                       (3주 2)
// 
// 실행 파일의 메모리 영역 - stack code data free store(heap)
//-----------------------------------------------------------------


// 문제 프로그램에서 이용할 수 있는 전역변수의 최대 크기는?

int num[100000000]{};	//초기화 하지 않은 data == default로 초기화한 data
//int num[100000000]{1};  //num[0]만 초기화 할 수 없다, 400mb이미지를 복사해야한다

int main(){
	num[99999999] = 1234567890;
	cout << num[99999999] << endl;
	cout << "키를 누르면 프로그램 끝 - ";
	char c;
	cin >> c;

	

	save("FileName.cpp");
}
	


// 실제로 실행해보면 메모리 위치가 다르다	


====================================================================================================
FileName.cpp, 저장시간: 2024-03-25 월요일 오후 6:27:20 
====================================================================================================
#include "save.h"
#include <string>
#include <array>
#include <numeric>
//-----------------------------------------------------------------
// 2024.03.25 1학기 stl 화 5~6 목 5~6                       (4주 1)
// 
// 메모리 동적할당 - RAII
//-----------------------------------------------------------------


// 문제 사용자가 입력한 int num 만큼 메모리를 동적할당하라
// int를 num개 동적할당한다
// 이 메모리를 1부터 시작하는 정수로 채운다
// 이 메모리의 합계를 화면에 출력한다
// 이 모든 과정을 영원히 반복하라

// -> run-time에서야 num값이 결정된다 --> new T[num]
// -> complie time에 모든 값이 결정 --> constexpr

int main()
{
	save("FileName.cpp");

	int num;
	while (1)
	{

		cout << "숫자를 입력하라 - ";
		cin >> num;

		int* p = new int[num];
		iota(p, p + num, 1);
		long long sum = accumulate(p, p + num, 0LL);  // 0울 int로 계산하기 때문에 값이 다르게 나온다 LL을 붙여 long long 으로 바꿔줘야 한다


		cout << "합계 - " << sum << endl;


		delete[] p;		// new와 짝이 맞는 delete를 코딩
	}

	
}


====================================================================================================
FileName.cpp, 저장시간: 2024-03-25 월요일 오후 6:56:45 
====================================================================================================
#include "save.h"
#include <string>
#include <array>
#include <numeric>
//-----------------------------------------------------------------
// 2024.03.25 1학기 stl 화 5~6 목 5~6                       (4주 1)
// 
// 메모리 동적할당 - RAII
// 
// 앞으로 c++ 에서 사용하지 않아야 할 것들
// char*  -> string 
// T[N]  -> array<T,N>
// T*    -> unique_ptr, shared_ptr( 스마트 포인터로 대체)
//-----------------------------------------------------------------


// 문제 사용자가 입력한 int num 만큼 메모리를 동적할당하라
// int를 num개 동적할당한다
// 이 메모리를 1부터 시작하는 정수로 채운다
// 이 메모리의 합계를 화면에 출력한다
// 이 모든 과정을 영원히 반복하라

// -> run-time에서야 num값이 결정된다 --> new T[num]
// -> complie time에 모든 값이 결정 --> constexpr

class Dog
{
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};
void f() 
{
	cout << "f 시작" << endl;
	Dog* p;
	{//예외 발생
		p = new Dog;
		throw 1234;		// catch 라인으로 이동
	}

	delete p;
	cout << "f 종료" << endl;
};

int main()
{
	save("FileName.cpp");
	cout << "메인 시작" << endl;

	try
	{
		f();// 자원을 확보하고 정리하는 함수
	}
	catch (...)
	{

	}

	cout << "메인 끝" << endl;
}




// 메모리 해제를 까먹음
// 메모리를 여러번 해제함 - dangling 프로그램이 바로 죽는다
// 지역을 벗어나면 반드시 소멸한다 - 연결시켜줘야한다



====================================================================================================
FileName.cpp, 저장시간: 2024-03-25 월요일 오후 7:04:58 
====================================================================================================
#include "save.h"
#include <string>
#include <array>
#include <numeric>
//-----------------------------------------------------------------
// 2024.03.25 1학기 stl 화 5~6 목 5~6                       (4주 1)
// 
// 메모리 동적할당 - RAII
// 
// 앞으로 c++ 에서 사용하지 않아야 할 것들
// char*  -> string 
// T[N]  -> array<T,N>
// T*    -> unique_ptr, shared_ptr( 스마트 포인터로 대체)
//-----------------------------------------------------------------


// 문제 사용자가 입력한 int num 만큼 메모리를 동적할당하라
// int를 num개 동적할당한다
// 이 메모리를 1부터 시작하는 정수로 채운다
// 이 메모리의 합계를 화면에 출력한다
// 이 모든 과정을 영원히 반복하라

// -> run-time에서야 num값이 결정된다 --> new T[num]
// -> complie time에 모든 값이 결정 --> constexpr

class Dog
{
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};


// RAII idiom(관용구) - 메모리, 파일, jthread

class Smart_ptr
{
	Dog* p;
public:
	Smart_ptr(Dog* p):p{p}{}
	~Smart_ptr()
	{
		delete p;
	}
};

void f() 
{
	cout << "f 시작" << endl;
	
	{//예외 발생
		Smart_ptr p{ new Dog };	// stack-unwinding   c++ 언어가 보장
		throw 1234;		// catch 라인으로 이동
	}


	cout << "f 종료" << endl;
};

int main()
{
	save("FileName.cpp");
	cout << "메인 시작" << endl;

	try
	{
		f();// 자원을 확보하고 정리하는 함수
	}
	catch (...)
	{

	}

	cout << "메인 끝" << endl;
}




// 메모리 해제를 까먹음
// 메모리를 여러번 해제함 - dangling 프로그램이 바로 죽는다
// 지역을 벗어나면 반드시 소멸한다 - 연결시켜줘야한다
// 예외 처리가되면 소멸이 안될 수 있다



====================================================================================================
FileName.cpp, 저장시간: 2024-03-26 화요일 오후 3:50:34 
====================================================================================================
#include "save.h"
#include <string>
#include <array>
#include <numeric>
#include <memory>
//-----------------------------------------------------------------
// 2024.03.26 1학기 stl 화 5~6 목 5~6                       (4주 2)
// 
// 
//-----------------------------------------------------------------



class Dog
{
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

int main()
{
	save("FileName.cpp");
	unique_ptr<Dog[]> p = make_unique<Dog[]>(3);

}





====================================================================================================
FileName.cpp, 저장시간: 2024-03-26 화요일 오후 4:08:54 
====================================================================================================
#include "save.h"
#include <string>
#include <array>
#include <numeric>
#include <memory>
//-----------------------------------------------------------------
// 2024.03.26 1학기 stl 화 5~6 목 5~6                       (4주 2)
// 
// 
//-----------------------------------------------------------------


//문제 "FileName.cpp"의 모든 소문자를 대문자로 바꿔 "stl대문자.txt"에 저장하라

int main()
{
	save("FileName.cpp");
	

	ifstream in{ "FileName.cpp",ios::binary};
	if (not in)
		return 33333333;

	ofstream out{ "stl대문자.txt",ios::binary };
	char c;
	
	while (in.read(&c, sizeof(char)))
		out << (c = toupper(c));	
}


====================================================================================================
FileName.cpp, 저장시간: 2024-03-26 화요일 오후 4:12:39 
====================================================================================================
#include "save.h"
#include <string>
#include <array>
#include <numeric>
#include <memory>
//-----------------------------------------------------------------
// 2024.03.26 1학기 stl 화 5~6 목 5~6                       (4주 2)
// 
// 
//-----------------------------------------------------------------


//문제 "FileName.cpp"의 모든 소문자를 대문자로 바꿔 "stl대문자.txt"에 저장하라

int main()
{
	save("FileName.cpp");
	

	ifstream in{ "FileName.cpp"};
	if (not in)
		return 33333333;

	ofstream out{ "stl대문자.txt"};
	char c;
	
	in >> noskipws;		// 공백을 건너뛰지 말아라
	while (in >> c)
	{
		c = toupper(c);
		cout << c;
	}
		
}


====================================================================================================
FileName.cpp, 저장시간: 2024-03-26 화요일 오후 4:26:26 
====================================================================================================
#include "save.h"
#include <string>
#include <array>
#include <numeric>
#include <memory>
#include <algorithm>
//-----------------------------------------------------------------
// 2024.03.26 1학기 stl 화 5~6 목 5~6                       (4주 2)
// 
// 
//-----------------------------------------------------------------


//문제 "FileName.cpp"의 모든 소문자를 대문자로 바꿔 "stl대문자.txt"에 저장하라

int main()
{
	save("FileName.cpp");
	

	ifstream in{ "FileName.cpp"};
	if (not in)
		return 33333333;

	ofstream out{ "stl대문자.txt"};
	
	transform(istreambuf_iterator<char>{in}, {}, ostreambuf_iterator<char>{out}, [](char c) {return c = toupper(c);});
		
}


====================================================================================================
FileName.cpp, 저장시간: 2024-03-26 화요일 오후 5:15:33 
====================================================================================================
#include "save.h"
#include <string>
#include <array>
#include <numeric>
#include <memory>
#include <algorithm>
#include <random>
#include <print>

//-----------------------------------------------------------------
// 2024.03.26 1학기 stl 화 5~6 목 5~6                       (4주 2)
// 
// 
//-----------------------------------------------------------------

//문제 [10000, 99999] 범위의 값을 갖는 int 100개를 만들어라
// qsort를 사용하여 오름차순으로 정렬하시오
// 정렬한 결과를 화면에 출력하세요


default_random_engine dre;
uniform_int_distribution uidNum{ 1,1000 };


int static compare(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}


int main()
{
	(*save)("FileName.cpp");	//함수 포인터 참조
	
	array<int,100> num;

	for (int& n : num)
		n = uidNum(dre);	
	
	//qsort로 정렬 - generic 함수라서 여기서 시작

	qsort(num.data(), num.size(), sizeof(int), [](const void* a, const void* b){
		return *(int*)a - *(int*)b;		//음수,0,양수
		});

	qsort(num.data(), num.size(), sizeof(int), compare);

	for (int n : num)
		print("{:8}", n);

}


====================================================================================================
FileName.cpp, 저장시간: 2024-03-26 화요일 오후 5:17:44 
====================================================================================================
#include "save.h"
#include <string>
#include <array>
#include <numeric>
#include <memory>
#include <algorithm>
#include <random>
#include <print>

//-----------------------------------------------------------------
// 2024.03.26 1학기 stl 화 5~6 목 5~6                       (4주 2)
// 
// 
//-----------------------------------------------------------------

//문제 [10000, 99999] 범위의 값을 갖는 int 100개를 만들어라
// qsort를 사용하여 오름차순으로 정렬하시오
// 정렬한 결과를 화면에 출력하세요


default_random_engine dre;
uniform_int_distribution uidNum{ 1,1000 };


int static compare(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}


int main()
{
	save("FileName.cpp");	//함수 포인터 참조
	
	auto a = compare;
	cout << typeid(a).name() << endl;

}


====================================================================================================
FileName.cpp, 저장시간: 2024-04-01 월요일 오후 5:59:17 
====================================================================================================
#include "save.h"
#include <string>
#include <array>
#include <numeric>
#include <memory>
#include <algorithm>
#include <random>
#include <print>

//-----------------------------------------------------------------
// 2024.04.1 1학기 stl				                        (5주 1)
// 
// 
// callable type
// 어떤 함수에 다른 함수를 전달한다
// sort할 때 어떤 기준으로 정렬할지를 어떻게 sort함수에게 알려주나?
// 1. 함수 포인터를 전달한다
// 2. 람다를 전달한다
//-----------------------------------------------------------------

//문제 [1, 1000] 범위의 값을 갖는 int 100개를 만들어라
// std::sort를 사용하여 오름차순으로 정렬하시오
// 정렬한 결과를 화면에 출력하세요


default_random_engine dre;
uniform_int_distribution uidNum{ 1,1000 };

int fcbt{};
bool f(int a, int b)
{
	fcbt++;
	return a > b;
}



int main()
{
	save("FileName.cpp");	//함수 포인터 참조
	array<int, 1000> num{};
	for (int& i : num)
		i = uidNum(dre);
	

	// std::sort 정렬 -default 오름차순(asending order)
	sort(num.begin(), num.end(), [](int a, int b) {return a < b; });


	for (int i : num)
		print("{:8}", i);

	cout << "횟수:" << fcbt;
}






====================================================================================================
FileName.cpp, 저장시간: 2024-04-01 월요일 오후 6:20:26 
====================================================================================================
#include "save.h"
#include <string>
#include <array>
#include <numeric>
#include <memory>
#include <algorithm>
#include <random>
#include <print>

//-----------------------------------------------------------------
// 2024.04.1 1학기 stl				                        (5주 1)
// 
// 
// callable type - 무한개의 타입이 있다
// 어떤 함수에 다른 함수를 전달한다
// sort할 때 어떤 기준으로 정렬할지를 어떻게 sort함수에게 알려주나?
// 1. 함수 포인터를 전달한다
// 2. 람다를 전달한다
// 3. ()연산자를 오버로딩한 클래스의 객체를 전달한다 (funtion call - () )
// 1과 2,3의 다른점 - 2,3은 상태를 가질 수 있다
//-----------------------------------------------------------------

//문제 [1, 1000] 범위의 값을 갖는 int 100개를 만들어라
// std::sort를 사용하여 오름차순으로 정렬하시오
// 정렬한 결과를 화면에 출력하세요


default_random_engine dre;
uniform_int_distribution uidNum{ 1,1000 };


class Dog
{
	int m;
public:
	bool operator()(int a, int b)		// 함수 호출 연산자 - ()
	{
		//return a + m < b;
		return a < b;
	}
};


int main()
{
	save("FileName.cpp");	//함수 포인터 참조
	array<int, 1000> num{};
	for (int& i : num)
		i = uidNum(dre);
	
	Dog dog;
	// std::sort 정렬 -default 오름차순(asending order)
	std::sort(num.begin(), num.end(), Dog{});


	for (int i : num)
		print("{:8}", i);

}






====================================================================================================
FileName.cpp, 저장시간: 2024-04-01 월요일 오후 7:05:30 
====================================================================================================
#include "save.h"
#include <string>
#include <array>
#include <numeric>
#include <memory>
#include <algorithm>
#include <random>
#include <print>
#include <functional>

//-----------------------------------------------------------------
// 2024.04.1 1학기 stl				                        (5주 1)
// 
// 
// callable type - 무한개의 타입이 있다
// 어떤 함수에 다른 함수를 전달한다
// sort할 때 어떤 기준으로 정렬할지를 어떻게 sort함수에게 알려주나?
// 1. 함수 포인터를 전달한다
// 2. 람다를 전달한다 - visual studio는 함수 객체로 구현
// 3. ()연산자를 오버로딩한 클래스의 객체를 전달한다 (funtion call - () )
//  함수 객체(function object)
// 1과 2,3의 다른점 - 2,3은 상태를 가질 수 있다
// 
// 호출가능한 타입을 대표하는 타입을 만들었다 - function 
// 
//-----------------------------------------------------------------


class String
{
	size_t len{};
	unique_ptr<char[]> p;
public:
	String(const char* s):len(strlen(s))
	{
		p = make_unique<char[]>(len);
		memcpy(p.get(), s, len);
	}

	friend ostream& operator<<(ostream& os, const String& str)
	{
		for (size_t i = 0; i < str.len; ++i)
			os << str.p.get()[i];
		return os;
	}
};



int main()
{
	save("FileName.cpp");
	String s{ "STL을 관찰하기 위한 클래스입니다" };
	//String t = s;
	cout << s << endl;
	//cout << t << endl;
}






====================================================================================================
FileName.cpp, 저장시간: 2024-04-02 화요일 오후 4:37:25 
====================================================================================================
#include <string>
#include <array>
#include <numeric>
#include <memory>
#include <algorithm>
#include <random>
#include <print>
#include <functional>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.2 1학기 stl				                        (5주 2)
// 
// 
//-----------------------------------------------------------------




int main()
{
	save("FileName.cpp");
	
	array<String, 5> a{ "2024년","4월","2일","화요일","STL시간" };
	
	
	// sort를 사용하여 a를 글자수 기준 오름차순으로 정렬한 후 출력하라

	sort(a.begin(), a.end(), [](const String& x, const String& y) {return x.getLen() < y.getLen(); });

	for (String& s : a)
		cout << s << endl;





}



//String t = s;		//디폴트 복사생성자를 만들 수 없다 - 스마트포인터는 복사생성이 불가


====================================================================================================
FileName.cpp, 저장시간: 2024-04-02 화요일 오후 5:17:08 
====================================================================================================
#include <string>
#include <array>
#include <numeric>
#include <memory>
#include <algorithm>
#include <random>
#include <print>
#include <functional>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.2 1학기 stl				                        (5주 2)
// 
// 
//-----------------------------------------------------------------

extern bool 관찰;


int main()
{
	save("FileName.cpp");
	
	array<String, 5> a{ "dsadsadasdad","sadasfsafasd","wqewqreqe","wqewqrqwwe","xzczxcvzxc" };
	
	
	// sort를 사용하여 a가 관리하는 String을 오름차순으로 정렬한 후 출력하라

	관찰 = true;

	for (const String& s : a)
		sort(s.getMem(), s.getMem() + s.getLen());
	관찰 = false;

	for (String& s : a)
		cout << s << endl;





}



//String t = s;		//디폴트 복사생성자를 만들 수 없다 - 스마트포인터는 복사생성이 불가


====================================================================================================
FileName.cpp, 저장시간: 2024-04-08 월요일 오후 6:37:28 
====================================================================================================
#include <array>
#include <list>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.8 1학기 stl				                        (6주 1)
// 
// STL - Container
// 
// Containers are objects that store other objects 컨테이너는 다른 오브젝트를 저장하는 오브젝트
// 오브젝트 - 클래스로 만들어진 객체
//-----------------------------------------------------------------

extern bool 관찰;


int main()
{
	save("FileName.cpp");
	array<int, 10>a{1,3,5,7,9,2,4,6,8,10};
	for (array<int, 10>::iterator p = a.begin(); p != a.end(); ++p)
		cout << p.operator*() << endl;

}



====================================================================================================
FileName.cpp, 저장시간: 2024-04-08 월요일 오후 6:56:52 
====================================================================================================
#include <array>
#include <list>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.8 1학기 stl				                        (6주 1)
// 
// STL - Container
// 
// Containers are objects that store other objects 컨테이너는 다른 오브젝트를 저장하는 오브젝트
// 오브젝트 - 클래스로 만들어진 객체
//-----------------------------------------------------------------

extern bool 관찰;


int main()
{
	save("FileName.cpp");
	array<int, 10>a{ 1,3,5,7,9,2,4,6,8,10 };

	int num;
	cin >> num;
	try 
	{
		a.at(num);//경계가 맞나 검사한다
	}
	catch (const exception& e)
	{
		cout << e.what() << endl;
	}
		
}

//syntactic sugar


====================================================================================================
FileName.cpp, 저장시간: 2024-04-08 월요일 오후 7:02:42 
====================================================================================================
#include <array>
#include <list>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.8 1학기 stl				                        (6주 1)
// 
// STL - Container
// 
// Containers are objects that store other objects 컨테이너는 다른 오브젝트를 저장하는 오브젝트
// 오브젝트 - 클래스로 만들어진 객체
//-----------------------------------------------------------------

extern bool 관찰;


int main()
{
	save("FileName.cpp");
	array<String, 100>a;

	//문제 a에 "FileName.cpp"에 있는 단어를 저장하라
	//a를 길이 오름차순으로 정렬하라
	//화면에 a를 출력하라

	ifstream in{ "FileName.cpp" };
	if (not in)
		return 123456;
	for (int i = 0; i < 100; ++i);
		//in >> a[i];
	
		
}

//syntactic sugar


====================================================================================================
FileName.cpp, 저장시간: 2024-04-09 화요일 오후 3:42:03 
====================================================================================================
#include <array>
#include <list>
#include <algorithm>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.9 1학기 stl				                        (6주 2)
// 
// STL - Container
// 
// Containers are objects that store other objects 컨테이너는 다른 오브젝트를 저장하는 오브젝트
// 오브젝트 - 클래스로 만들어진 객체
//-----------------------------------------------------------------

extern bool 관찰;


int main()
{
	save("FileName.cpp");
	array<String, 100>a;

	//문제 a에 "FileName.cpp"에 있는 단어를 저장하라
	//a를 길이 오름차순으로 정렬하라
	//화면에 a를 출력하라

	ifstream in{ "FileName.cpp" };
	if (not in)
		return 123456;
	for (int i = 0; i < 100; ++i)
		in >> a[i];			//operator>>(in, a[i]);
	
	sort(a.begin(), a.end(), [](const String& a,const String& b) {return a.getLen() < b.getLen(); });
	
	for (const String& s : a)
		cout << s << endl;


		
}




====================================================================================================
FileName.cpp, 저장시간: 2024-04-09 화요일 오후 4:13:21 
====================================================================================================
#include <vector>
#include <random>
#include <print>
#include <ranges>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.9 1학기 stl				                        (6주 2)
// 
// vector - dynamic array
//-----------------------------------------------------------------

extern bool 관찰;


default_random_engine dre;
uniform_int_distribution uid{ 1,10000 };

int main()	
{
	save("FileName.cpp");

	// 예제 int값 num을 입력받아 v에 [1,10000]값을 갖는 int num개를 추가
	// 오름차순 정렬한다
	// 값을 출력한다
	
	while (1)
	{
		vector<int>v;
		int num;

		cout << "숫자 입력";
		cin >> num;

		for (int i = 0; i < num; ++i)
			v.push_back(uid(dre));

		sort(v.begin(), v.end());

		// 앞에서 100개만
		for (int n : v | views::take(100))
			print("{:8}", n);
	}
}



====================================================================================================
FileName.cpp, 저장시간: 2024-04-09 화요일 오후 5:06:10 
====================================================================================================
#include <vector>
#include <numeric>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.9 1학기 stl				                        (6주 2)
// 
// vector - dynamic array
//-----------------------------------------------------------------

extern bool 관찰;



int main()	
{
	save("FileName.cpp");


	//문제 키보드에서 입력한 int값의 합계와 평균을 출력하라
	//문제 키보드에서 입력한 String을 길이 오름차순 정렬하여 출력하라
	
	vector<int> v{ istream_iterator<int>{cin},{} };		//cin - 키보드 입력  {}키보드 입력 끝

	int sum = accumulate(v.begin(), v.end(), 0);
	cout << "합계 " << sum << endl;
	cout << "평균 " << format("{:.2f}", sum / (double)v.size()) << endl;
	
}



====================================================================================================
FileName.cpp, 저장시간: 2024-04-09 화요일 오후 5:19:19 
====================================================================================================
#include <vector>
#include <numeric>
#include <algorithm>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.9 1학기 stl				                        (6주 2)
// 
// vector - dynamic array
//-----------------------------------------------------------------

extern bool 관찰;



int main()	
{
	save("FileName.cpp");


	//문제 키보드에서 입력한 int값의 합계와 평균을 출력하라
	//문제 키보드에서 입력한 String을 길이 오름차순 정렬하여 출력하라
	
	vector<String> v{ istream_iterator<String>{cin},{} };		//cin - 키보드 입력  {}키보드 입력 끝

	sort(v.begin(), v.end(), [](const String& a,const String& b) {return a.getLen()< b.getLen(); });
	for (const String& s : v)
		cout << s << endl;
}



====================================================================================================
FileName.cpp, 저장시간: 2024-04-15 월요일 오후 5:27:59 
====================================================================================================
#include <vector>
#include <numeric>
#include <algorithm>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.15 1학기 stl				                        (7주 1)
// 
// vector - dynamic array
//-----------------------------------------------------------------

extern bool 관찰;



int main()	
{
	save("FileName.cpp");

	//문제 키보드에서 입력한 int값의 합계와 평균을 출력하라
	//문제 키보드에서 입력한 String을 길이 오름차순 정렬하여 출력하라
	
	vector<String> v{ istream_iterator<String>{cin},{} };		//cin - 키보드 입력  {}키보드 입력 끝

	sort(v.begin(), v.end(), [](const String& a,const String& b) {return a.getLen()< b.getLen(); });
	for (const String& s : v)
		cout << s << endl;
}



====================================================================================================
FileName.cpp, 저장시간: 2024-04-15 월요일 오후 6:09:46 
====================================================================================================
#include <vector>
#include <numeric>
#include <algorithm>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.15 1학기 stl				                        (7주 1)
// 
// vector - dynamic array
//-----------------------------------------------------------------

extern bool 관찰;



int main()	
{
	save("FileName.cpp");

	관찰 = true;
	vector<String>v;
	
	v.push_back("1");
	cout << endl << endl;
	v.push_back("22");
	cout << endl << endl;

}


====================================================================================================
FileName.cpp, 저장시간: 2024-04-15 월요일 오후 6:27:04 
====================================================================================================
#include <vector>
#include <numeric>
#include <algorithm>
#include <array>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.15 1학기 stl				                        (7주 1)
// 
// vector - dynamic array
//-----------------------------------------------------------------

extern bool 관찰;



int main()	
{
	save("FileName.cpp");

	// 문제 FileName.cpp 에 있는 알파벳 소문자의 출현 횟수를 다음과 같이 출력하라
	// a - 20
	// b - 3
	// c - 1
	// ...
	// z - 2

	
	array<int, 26> alpha;

	ifstream in{ "FileName.cpp" };
	if (not in)
		return 123;

	char c;

	for (int& n : alpha)
		n = 0;

	while (in.read(&c, sizeof(char)))
	{
		if (static_cast<int>(c)>=97 && static_cast<int>(c)<=122)
		alpha[static_cast<int>(c)-97] += 1;
	}

	for (int i = 0; i < 26; i++)
	{
		cout << char(static_cast<int>(i + 97)) << " - " << alpha[i] << endl;
	}

}


====================================================================================================
FileName.cpp, 저장시간: 2024-04-15 월요일 오후 6:43:00 
====================================================================================================
#include <vector>
#include <numeric>
#include <algorithm>
#include <array>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.15 1학기 stl				                        (7주 1)
// 
// vector - dynamic array
//-----------------------------------------------------------------

extern bool 관찰;



int main()	
{
	save("FileName.cpp");

	// 문제 FileName.cpp 에 있는 알파벳 소문자의 출현 횟수를 다음과 같이 출력하라
	// a - 20
	// b - 3
	// c - 1
	// ...
	// z - 2
	//islower() - 알파벳 소문자 판별
	
	array<int, 26> alpha{};//{} - 초기화
	//vector<int> a(26) - (26)으로 초기화 해야한다

	ifstream in{ "FileName.cpp" };
	if (not in)
		return 123;

	char c;

	//while(in>>c)
	while (in.read(&c, sizeof(char)))
	{
		
		//if (static_cast<int>(c)>=97 && static_cast<int>(c)<=122)
		if (iswlower(c))
			alpha[static_cast<int>(c)-97] += 1;// alpha[c - 'a'] += 1;
	}

	for (int i = 0; i < 26; i++)
	{
		cout << char(i + 97) << " - " << alpha[i] << endl;
	}

}


====================================================================================================
FileName.cpp, 저장시간: 2024-04-15 월요일 오후 7:04:19 
====================================================================================================
#include <vector>
#include <numeric>
#include <algorithm>
#include <array>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.15 1학기 stl				                        (7주 1)
// 
// vector - dynamic array
//-----------------------------------------------------------------

extern bool 관찰;



int main()	
{
	save("FileName.cpp");

	vector<int> v{ 1,2,3,4,5 };
	//문제 v에서 3을 제거하고 출력하라
	// erase-remove idiom

	//auto p = remove(v.begin(), v.end(), 3);
	//v.erase(p, v.end());

	v.erase(remove(v.begin(), v.end(), 3), v.end());


	for (int num : v)
		cout << num << ' ' << endl;		// 1 2 4 5 5    한칸씩 땡긴다
}


====================================================================================================
FileName.cpp, 저장시간: 2024-04-16 화요일 오후 3:35:31 
====================================================================================================
#include <vector>
#include <numeric>
#include <algorithm>
#include <array>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.16 1학기 stl				                        (7주 2)
// 
// vector - dynamic array
//-----------------------------------------------------------------

extern bool 관찰;



int main()	
{
	save("FileName.cpp");

	vector<int> v{ 1,2,3,4,5 };
	//문제 v에서 3을 제거하고 출력하라		c++20 부터는 erase(v, 3);
	// erase-remove idiom
	
	//auto p = remove(v.begin(), v.end(), 3);
	//v.erase(p, v.end());

	v.erase(remove(v.begin(), v.end(), 3), v.end());

		
	for (int num : v)
		cout << num << ' ' << endl;		// 1 2 4 5 5    한칸씩 땡긴다
}


====================================================================================================
FileName.cpp, 저장시간: 2024-04-16 화요일 오후 3:55:16 
====================================================================================================
#include <vector>
#include <numeric>
#include <algorithm>
#include <array>
#include <print>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.16 1학기 stl				                        (7주 2)
// 
// vector - dynamic array
//-----------------------------------------------------------------

extern bool 관찰;



int main()	
{
	save("FileName.cpp");

	vector<int> v(200);
	//문제 v에서 홀수를 제거하라

	iota(v.begin(), v.end(), 1);
	erase_if(v, [](int num) {return num % 2; });
	
		

	for (int num : v)
		print("{:8}", num);
	
		
}


====================================================================================================
FileName.cpp, 저장시간: 2024-04-16 화요일 오후 4:17:14 
====================================================================================================
#include <vector>
#include <numeric>
#include <algorithm>
#include <array>
#include <print>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.16 1학기 stl				                        (7주 2)
// 
// vector - dynamic array
//-----------------------------------------------------------------

extern bool 관찰;



int main()	
{
	save("FileName.cpp");

	vector<String> v{ "1","2","3","4","5","3","33"};
	
	//문제 v에서 "3"을 삭제하라

	//erase(v, "3");
	erase_if(v, [](String s) {return s == "3"; });

	for (const String& s : v)
		cout << s << endl;

		
}


====================================================================================================
FileName.cpp, 저장시간: 2024-04-16 화요일 오후 4:39:21 
====================================================================================================
#include <vector>
#include <numeric>
#include <algorithm>
#include <array>
#include <print>
#include <list>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.16 1학기 stl				                        (7주 2)
// 
// vector - dynamic array - 중간위치에서 원소 추가/삭제 지양
//-----------------------------------------------------------------

extern bool 관찰;



int main()	
{
	save("FileName.cpp");

	
	list<String> v{ "1","22","4444","55555" };
	auto p = v.begin();
	++p;
	++p;
	관찰 = true;
	v.emplace(p, "333");
	//v.insert(p, "333");
	관찰 = false;
	for (const String& s : v)
		cout << s << endl;

		
}


====================================================================================================
FileName.cpp, 저장시간: 2024-04-16 화요일 오후 5:19:05 
====================================================================================================
#include <deque>
#include <vector>
#include <list>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.16 1학기 stl				                        (7주 2)
//  
// deque - vecto와 list의 중간형태를 띄는 자료구조다
//-----------------------------------------------------------------

extern bool 관찰;

class Test
{
	char x[4096];
};

int main()	
{
	save("FileName.cpp");
	//vector<Test> v;  //1574803
	//deque<Test> v;   //2500000
	list<Test>v;	   //2500000
	while (1)
	{
		try
		{
			v.push_back(Test{});
		}
		catch (...)
		{
			cout << "끝" << endl;
			cout << v.size() << endl;
			break;
		}
		if (!(v.size() % 100000))
			cout << v.size() << endl;
	}
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-04-22 월요일 오후 5:53:37 
====================================================================================================
#include <list>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.22 1학기 stl				                        (8주 1)
//  
// list
//-----------------------------------------------------------------

extern bool 관찰;


int main()	
{
	save("FileName.cpp");
	list<String> container;
	cout << "리스트의 크기 - " << sizeof container << endl;
	관찰 = true;
	container.emplace_back("333");
	container.emplace_front("1");
	container.emplace(++container.begin(),"22");
	관찰 = false;


	cout << endl;
	for (const String& s : container)
		cout << s << endl;



}                


====================================================================================================
FileName.cpp, 저장시간: 2024-04-22 월요일 오후 6:09:41 
====================================================================================================
#include <list>
#include <fstream>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.22 1학기 stl				                        (8주 1)
//  
// list
//-----------------------------------------------------------------

extern bool 관찰;


int main()	
{
	save("FileName.cpp");
	list<String>container;
	관찰 = true;
	//문제 String.cpp에 있는 단어를 container에 저장하라
	ifstream in{ "String.cpp" };
	if (not in)
	{
		return 1234;
	}
	

	String s;
	while (in >> s)
	{
		container.emplace_back(s);
	}
	while (in)
	{
		in >> container.emplace_back();
	}

	container = { istream_iterator<String>{in},{} };

	관찰 = false;


	cout << endl;
	for (const String& s : container)
		cout << s << endl;



}                


====================================================================================================
FileName.cpp, 저장시간: 2024-04-22 월요일 오후 6:29:41 
====================================================================================================
#include <algorithm>
#include <fstream>
#include <list>
#include <ranges>
#include "save.h"
#include "String.h"
//-----------------------------------------------------------------
// 2024.04.22 1학기 stl				                        (8주 1)
//  
// list
//-----------------------------------------------------------------

extern bool 관찰;


int main()	
{
	save("FileName.cpp");
	list<String>container;
	관찰 = true;
	//문제 container를 길이오름차순으로 정렬하라
	ifstream in{ "String.cpp" };
	if (not in)
	{
		return 1234;
	}
	
	while (in)
	{
		in >> container.emplace_back();
	}

	container.sort([](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	//sort(container.begin(), container.end(), [](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	//sort(container, [](const String& a, const String& b) {return a.getLen() < b.getLen(); });


	관찰 = false;


	cout << endl;
	for (const String& s : container)
		cout << s << endl;



}                


====================================================================================================
FileName.cpp, 저장시간: 2024-04-22 월요일 오후 6:32:19 
====================================================================================================
#include <algorithm>
#include <fstream>
#include <list>
#include <ranges>
#include "save.h"
#include "String.h"
//-----------------------------------------------------------------
// 2024.04.22 1학기 stl				                        (8주 1)
//  
// list
//-----------------------------------------------------------------

extern bool 관찰;


int main()	
{
	save("FileName.cpp");
	list<String>container;
	관찰 = true;
	//문제 container를 길이오름차순으로 정렬하라
	ifstream in{ "String.cpp" };
	if (not in)
	{
		return 1234;
	}
	
	while (in)
	{
		in >> container.emplace_back();
	}

	container.sort([](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	//sort(container.begin(), container.end(), [](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	//sort(container, [](const String& a, const String& b) {return a.getLen() < b.getLen(); });


	관찰 = false;


	cout << endl;
	for (const String& s : container)
		cout << s << endl;



}                


====================================================================================================
FileName.cpp, 저장시간: 2024-04-22 월요일 오후 6:41:56 
====================================================================================================
#include <algorithm>
#include <fstream>
#include <list>
#include <ranges>
#include "save.h"
#include "String.h"
//-----------------------------------------------------------------
// 2024.04.22 1학기 stl				                        (8주 1)
//  
// list
//-----------------------------------------------------------------

extern bool 관찰;


int main()	
{
	save("FileName.cpp");
	list<String>container;
	관찰 = true;
	//문제 container를 길이오름차순으로 정렬하라
	ifstream in{ "String.cpp" };
	if (not in)
	{
		return 1234;
	}
	
	while (in)
	{
		in >> container.emplace_back();
	}

	container.sort([](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	//sort(container.begin(), container.end(), [](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	//sort(container, [](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	
	//원소의 순서를 거꾸로 뒤집어라
	container.reverse();


	관찰 = false;


	cout << endl;
	for (const String& s : container)
		cout << s << endl;



}                


====================================================================================================
FileName.cpp, 저장시간: 2024-04-22 월요일 오후 6:45:43 
====================================================================================================
#include <algorithm>
#include <fstream>
#include <list>
#include <ranges>
#include "save.h"
#include "String.h"
//-----------------------------------------------------------------
// 2024.04.22 1학기 stl				                        (8주 1)
//  
// list
//-----------------------------------------------------------------

extern bool 관찰;


int main()	
{
	save("FileName.cpp");
	list<String>container;
	관찰 = true;
	//문제 container를 길이오름차순으로 정렬하라
	ifstream in{ "String.cpp" };
	if (not in)
	{
		return 1234;
	}
	
	while (in)
	{
		in >> container.emplace_back();
	}

	container.sort([](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	//sort(container.begin(), container.end(), [](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	//sort(container, [](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	
	//원소의 순서를 거꾸로 뒤집어라
	container.reverse();


	관찰 = false;


	// 출력을 거꾸로 해라

	cout << endl;
	for (const String& s : container)
		cout << s << endl;
	for (auto p = container.rbegin(); p != container.rend(); ++p)
		cout << *p << endl;
	

}                


====================================================================================================
FileName.cpp, 저장시간: 2024-04-22 월요일 오후 7:00:48 
====================================================================================================
#include <algorithm>
#include <fstream>
#include <list>
#include <ranges>
#include "save.h"
#include "String.h"
//-----------------------------------------------------------------
// 2024.04.22 1학기 stl				                        (8주 1)
//  
// list
//-----------------------------------------------------------------

extern bool 관찰;


int main()	
{
	save("FileName.cpp");
	list<String>container;
	관찰 = true;
	//문제 container를 길이오름차순으로 정렬하라
	ifstream in{ "String.cpp" };
	if (not in)
	{
		return 1234;
	}
	
	while (in)
	{
		in >> container.emplace_back();
	}

	container.sort([](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	//sort(container.begin(), container.end(), [](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	//sort(container, [](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	
	//원소의 순서를 거꾸로 뒤집어라
	container.reverse();


	관찰 = false;


	// 출력을 거꾸로 해라

	cout << endl;
	for (const String& s : container)
		cout << s << endl;
	for (auto p = container.rbegin(); p != container.rend(); ++p)
		cout << *p << endl;

	// 문제 길이가 5인 것들만 화면에 출력하라
	for (const String& s : container)
		if (s.getLen() == 5)
			cout << s << endl;

}                


====================================================================================================
FileName.cpp, 저장시간: 2024-04-22 월요일 오후 10:07:45 
====================================================================================================
#include <algorithm>
#include <fstream>
#include <list>
#include <ranges>
#include "save.h"
#include "String.h"
//-----------------------------------------------------------------
// 2024.04.22 1학기 stl				                        (8주 1)
//  
// list
//-----------------------------------------------------------------

extern bool 관찰;


int main()	
{
	save("FileName.cpp");
	list<String>container;
	관찰 = true;
	//문제 container를 길이오름차순으로 정렬하라
	ifstream in{ "String.cpp" };
	if (not in)
	{
		return 1234;
	}
	
	while (in)
	{
		in >> container.emplace_back();
	}

	container.sort([](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	//sort(container.begin(), container.end(), [](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	//sort(container, [](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	
	//원소의 순서를 거꾸로 뒤집어라
	container.reverse();


	관찰 = false;


	// 출력을 거꾸로 해라

	cout << endl;
	for (const String& s : container)
		cout << s << endl;
	for (auto p = container.rbegin(); p != container.rend(); ++p)
		cout << *p << endl;

	// 문제 길이가 5인 것들만 화면에 출력하라
	for (const String& s : container)
		if (s.getLen() == 5)
			cout << s << endl;

}                


====================================================================================================
FileName.cpp, 저장시간: 2024-04-23 화요일 오후 2:49:24 
====================================================================================================
#include <algorithm>
#include <fstream>
#include <list>
#include <ranges>
#include "save.h"
#include "String.h"
//-----------------------------------------------------------------
// 2024.04.22 1학기 stl				                        (8주 1)
//  
// list
//-----------------------------------------------------------------

extern bool 관찰;


int main()	
{
	save("FileName.cpp");
	list<String>container;
	관찰 = true;
	//문제 container를 길이오름차순으로 정렬하라
	ifstream in{ "String.cpp" };
	if (not in)
	{
		return 1234;
	}
	
	while (in)
	{
		in >> container.emplace_back();
	}

	container.sort([](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	//sort(container.begin(), container.end(), [](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	//sort(container, [](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	
	//원소의 순서를 거꾸로 뒤집어라
	container.reverse();


	관찰 = false;


	// 출력을 거꾸로 해라

	cout << endl;
	for (const String& s : container)
		cout << s << endl;
	for (auto p = container.rbegin(); p != container.rend(); ++p)
		cout << *p << endl;

	// 문제 길이가 5인 것들만 화면에 출력하라
	for (const String& s : container)
		if (s.getLen() == 5)
			cout << s << endl;

}                


====================================================================================================
FileName.cpp, 저장시간: 2024-04-23 화요일 오후 2:49:39 
====================================================================================================
#include <algorithm>
#include <fstream>
#include <list>
#include <ranges>
#include "save.h"
#include "String.h"
//-----------------------------------------------------------------
// 2024.04.22 1학기 stl				                        (8주 1)
//  
// list
//-----------------------------------------------------------------

extern bool 관찰;


int main()	
{
	save("FileName.cpp");
	list<String>container;
	관찰 = true;
	//문제 container를 길이오름차순으로 정렬하라
	ifstream in{ "String.cpp" };
	if (not in)
	{
		return 1234;
	}
	
	while (in)
	{
		in >> container.emplace_back();
	}

	container.sort([](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	//sort(container.begin(), container.end(), [](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	//sort(container, [](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	
	//원소의 순서를 거꾸로 뒤집어라
	container.reverse();


	관찰 = false;


	// 출력을 거꾸로 해라

	cout << endl;
	for (const String& s : container)
		cout << s << endl;
	for (auto p = container.rbegin(); p != container.rend(); ++p)
		cout << *p << endl;

	// 문제 길이가 5인 것들만 화면에 출력하라
	for (const String& s : container)
		if (s.getLen() == 5)
			cout << s << endl;

}                


====================================================================================================
FileName.cpp, 저장시간: 2024-04-23 화요일 오후 2:50:15 
====================================================================================================
#include <algorithm>
#include <fstream>
#include <list>
#include <ranges>
#include "save.h"
#include "String.h"
//-----------------------------------------------------------------
// 2024.04.22 1학기 stl				                        (8주 1)
//  
// list
//-----------------------------------------------------------------

extern bool 관찰;


int main()	
{
	save("FileName.cpp");
	list<String>container;
	관찰 = true;
	//문제 container를 길이오름차순으로 정렬하라
	ifstream in{ "String.cpp" };
	if (not in)
	{
		return 1234;
	}
	
	while (in)
	{
		in >> container.emplace_back();
	}

	container.sort([](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	//sort(container.begin(), container.end(), [](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	//sort(container, [](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	
	//원소의 순서를 거꾸로 뒤집어라
	container.reverse();


	관찰 = false;


	// 출력을 거꾸로 해라

	cout << endl;
	for (const String& s : container)
		cout << s << endl;
	for (auto p = container.rbegin(); p != container.rend(); ++p)
		cout << *p << endl;

	// 문제 길이가 5인 것들만 화면에 출력하라
	for (const String& s : container)
		if (s.getLen() == 5)
			cout << s << endl;

}                


====================================================================================================
FileName.cpp, 저장시간: 2024-04-23 화요일 오후 2:51:38 
====================================================================================================
#include <algorithm>
#include <fstream>
#include <list>
#include <ranges>
#include "save.h"
#include "String.h"
//-----------------------------------------------------------------
// 2024.04.22 1학기 stl				                        (8주 1)
//  
// list
//-----------------------------------------------------------------

extern bool 관찰;


int main()	
{
	save("FileName.cpp");
	list<String>container;
	관찰 = true;
	//문제 container를 길이오름차순으로 정렬하라
	ifstream in{ "String.cpp" };
	if (not in)
	{
		return 1234;
	}
	
	while (in)
	{
		in >> container.emplace_back();
	}

	container.sort([](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	//sort(container.begin(), container.end(), [](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	//sort(container, [](const String& a, const String& b) {return a.getLen() < b.getLen(); });
	
	//원소의 순서를 거꾸로 뒤집어라
	container.reverse();


	관찰 = false;


	// 출력을 거꾸로 해라

	cout << endl;
	for (const String& s : container)
		cout << s << endl;
	for (auto p = container.rbegin(); p != container.rend(); ++p)
		cout << *p << endl;

	// 문제 길이가 5인 것들만 화면에 출력하라
	for (const String& s : container)
		if (s.getLen() == 5)
			cout << s << endl;

}                


====================================================================================================
FileName.cpp, 저장시간: 2024-04-30 화요일 오후 4:31:59 
====================================================================================================
#include <algorithm>
#include <fstream>
#include <list>
#include <ranges>
#include "save.h"
#include "String.h"
//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (9주 2)
//  
// 
//-----------------------------------------------------------------

extern bool 관찰;


int main()	
{
	save("FileName.cpp");
	list<String> name1{ "이준","이현","이서","서아","은우" };
	list<String> name2{ "하준","연우","시우","지안","도윤","서윤" };
	
	name1.sort();	//이미 <연산자를 코딩해서 디폴트 sorting 가능
	name2.sort();
	// 문제 리스트 2개를 하나로 합쳐라
	관찰 = true;
	name1.merge(name2);
	관찰 = false;
	// 미리 리스트를 sorting해야 한다

	for (const String& s : name1)
		cout << s << endl;
	
	for (const String& s : name2)
		cout << s << endl;

}                


====================================================================================================
FileName.cpp, 저장시간: 2024-04-30 화요일 오후 5:03:23 
====================================================================================================
#include <algorithm>
#include <fstream>
#include <list>
#include <ranges>
#include "save.h"
#include "String.h"
//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (9주 2)
//  
// 
//-----------------------------------------------------------------

extern bool 관찰;


int main()	
{
	save("FileName.cpp");
	
	//문제 "FileName.cpp"의 소문자를 list<char>에 push_back()으로 저장하라
	//출력하라
	//모든 소문자가 다 있나 확인하라


	ifstream in{ "FileName.cpp" };
	if (not in)
		return 12345;
	char c;
	vector<char> List;
	//list<char> List;
	
	while (in >> c)
		if (islower(c))
			List.push_back(c);
	sort(List.begin(), List.end());
	auto p = unique(List.begin(), List.end());
	List.erase(p, List.end());			//지워줘야한다
	//List.sort();	
	//List.unique();

	for (const char& c : List)
		cout << c;
	cout << endl;

	
	if (List.size() == 26)
		cout << "모든 문자가 있다" << endl;
	else
		cout << "없다" << endl;



}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 5:51:15 
====================================================================================================
#include <algorithm>
#include <fstream>
#include <list>
#include <ranges>
#include <numeric>
#include <span>
#include <print>
#include "save.h"
#include "String.h"
//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (10주 1)
//  
// 
//-----------------------------------------------------------------

extern bool 관찰;


int main()	
{
	save("FileName.cpp");
	int a[100];
	iota(begin(a), end(a), 1);
	span<int> s{ a };
	
	for (auto i = s.rbegin(); i != s.rend(); ++i)
		print("{:8}", *i);
	cout << endl;

	
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 6:33:54 
====================================================================================================
#include <algorithm>
#include <fstream>
#include <list>
#include <ranges>
#include <numeric>
#include <span>
#include <print>
#include "save.h"
#include "String.h"
//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (10주 1)
//  
// iterator -iterator are a generalization of pointers
// 포인터를 일반화 한 것이 반복자다. 이걸 사용하면 자료구조가 뭔지
// 신경쓸 필요없이 동일한 방식으로 코딩할 수 있다
//-----------------------------------------------------------------

extern bool 관찰;


int main()	
{
	save("FileName.cpp");
	// 반복자란 무엇인가
	// 출력스트림 반복자(stream 반복자, 반복자 어댑터)의 동작을 통해 반복자가 
	// 무엇인지 알아본다
	// 반복자는 포인터가 절대 아니다

	ostream_iterator<char> p{ cout };
	*p = 'A';
	//(p.operator*()).operator=('A');
	++p;
	//p.operator++();
	*p = 'B';
	++p;
	*p = 'C';


	
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 6:34:30 
====================================================================================================
#include <algorithm>
#include <fstream>
#include <list>
#include <ranges>
#include <numeric>
#include <span>
#include <print>
#include "save.h"
#include "String.h"
//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (10주 1)
//  
// iterator -iterator are a generalization of pointers
// 포인터를 일반화 한 것이 반복자다. 이걸 사용하면 자료구조가 뭔지
// 신경쓸 필요없이 동일한 방식으로 코딩할 수 있다
//-----------------------------------------------------------------

extern bool 관찰;


int main()	
{
	save("FileName.cpp");
	// 반복자란 무엇인가
	// 출력스트림 반복자(stream 반복자, 반복자 어댑터)의 동작을 통해 반복자가 
	// 무엇인지 알아본다
	// 반복자는 포인터가 절대 아니다

	ostream_iterator<char> p{ cout };
	p = 'A';	
	p = 'B';
	p = 'C';


	
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-07 화요일 오후 3:32:37 
====================================================================================================
#include <forward_list>
#include <list>
#include <deque>
#include <vector>
#include <iterator>
#include "save.h"
#include "String.h"
//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (10주 2)
//  
// iterator -iterator are a generalization of pointers
// 포인터를 일반화 한 것이 반복자다. 이걸 사용하면 자료구조가 뭔지
// 신경쓸 필요없이 동일한 방식으로 코딩할 수 있다
//-----------------------------------------------------------------

extern bool 관찰;


template <class 반복자>
void f(반복자 iter)
{
	//c++17 이후
	// 벡터만 컴파일 통과
	// 다른 컨테이너는 실패 - SFINAE
	cout << typeid(반복자::iterator_category).name() << endl;
	//iterator_category
}

int main()	
{
	save("FileName.cpp");
	// 반복자란 무엇인가.
	// 출력스트림 반복자(stream 반복자, 반복자 어댑터)의 동작을 통해 반복자가 
	// 무엇인지 알아본다
	// 반복자는 포인터가 절대 아니다

	// 문제 반복자는 6가지 종류가 있다
	// 함수 f에게 반복자를 인자로 넘겨주면 어떤 종류인지 출력하게 하라
	
	// 문제 벡터가 contiguous 인지 판별하려면 질문을 바꿔야 한다



	//f(istream_iterator<string>{cin});
	//f(ostream_iterator<String>{cout});
	//f(forward_list<char>::iterator{});
	//f(list<double>::reverse_iterator{});
	//f(deque<int>{}.cbegin());
	//f(vector<int>{}.begin());	//벡터의 반복자는 다른 반복자 종류가 될 수 있다 
	//
	//f(int{});






	
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-07 화요일 오후 4:21:57 
====================================================================================================
#include "String.h"
#include "save.h"


#include <span>


//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (10주 2)
//  
//
//-----------------------------------------------------------------

extern bool 관찰;




int main()	
{
	save("FileName.cpp");
	
	string s{ "1357924680" };
	// 문제  다음 문장이 실행되게 하라
	// 문제 거꾸로 출력하라

	//span<char> sp{ s.begin(),s.end() };
	//for (auto i = sp.rbegin(); i != sp.rend(); ++i)
	//	cout << *i << ' ';
	//cout << endl;

	//for (auto i = s.begin(); i != s.end(); ++i)
	//	cout << *i << ' ';
	//cout << endl;

	//for (auto i = s.rbegin(); i != s.rend(); ++i)
	//	cout << *i << ' ';
	//cout << endl;

	
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-07 화요일 오후 4:52:27 
====================================================================================================
#include "String.h"
#include "save.h"


#include <span>


//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (10주 2)
//  
//
//-----------------------------------------------------------------

extern bool 관찰;




int main()	
{
	save("FileName.cpp");
	
	String s{ "1357924680" };
	
	// 문제  다음 문장이 실행되게 하라
	// 문제 거꾸로 출력하라

	//span<char> sp{ s.begin(),s.end() };
	//for (auto i = sp.rbegin(); i != sp.rend(); ++i)
	//	cout << *i << ' ';
	//cout << endl;

	for (auto i = s.begin(); i != s.end(); ++i)
		cout << *i << ' ';
	cout << endl;


	//자동으로 !=를 만들어준다
	for (auto i = s.rbegin(); i !=s.rend(); i.operator++())
		cout << i.operator*() << ' ';
	cout << endl;

	
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-07 화요일 오후 5:19:40 
====================================================================================================
#include "String.h"
#include "save.h"
#include <vector>

#include <span>


//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (10주 2)
//  
//
//-----------------------------------------------------------------

extern bool 관찰;

template <class 반복자>
void f(반복자 iter)
{
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
	//c++17
	cout << typeid(반복자::iterator_concept).name() << endl;
}



int main()	
{
	save("FileName.cpp");
	
	String s{ "1357924680" };
	
	// 문제  다음 문장이 실행되게 하라
	// 문제 거꾸로 출력하라

	//span<char> sp{ s.begin(),s.end() };
	//for (auto i = sp.rbegin(); i != sp.rend(); ++i)
	//	cout << *i << ' ';
	//cout << endl;

	//반복자의 속성을 확인하는 표준 질문에 응답할 수 있어야 한다
	//c++ 표준을 지키는 반복자가 되려면 다음 다섯가지 항목을 정의해야한다
	// difference type
	// value type
	// pointer
	// reference
	// itertor category

	f(s.rbegin());


	for (auto i = s.begin(); i != s.end(); ++i)
		cout << *i << ' ';
	cout << endl;


	//자동으로 !=를 만들어준다
	for (auto i = s.rbegin(); i !=s.rend(); i.operator++())
		cout << i.operator*() << ' ';
	cout << endl;

	
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-07 화요일 오후 5:21:57 
====================================================================================================
#include "String.h"
#include "save.h"
#include <vector>
#include <algorithm>
#include <string>
#include <span>


//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (10주 2)
//  
//
//-----------------------------------------------------------------

extern bool 관찰;

template <class 반복자>
void f(반복자 iter)
{
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
	//c++17
	cout << typeid(반복자::iterator_concept).name() << endl;
}



int main()	
{
	save("FileName.cpp");
	
	string s{ "1357924680" };
	
	
	sort(s.rbegin(), s.rend());
	cout << s << endl;
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 5:31:27 
====================================================================================================
#include "String.h"
#include "save.h"
#include <vector>
#include <algorithm>
#include <string>
#include <span>


//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (11주 1)
//  
//
//-----------------------------------------------------------------

extern bool 관찰;

template <class 반복자>
void f(반복자 iter)
{
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
	//c++17
	cout << typeid(반복자::iterator_concept).name() << endl;
}



int main()	
{
	save("FileName.cpp");
	
	string s{ "1357924680" };
	
	
	sort(s.rbegin(), s.rend());
	cout << s << endl;
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 5:41:07 
====================================================================================================
#include <algorithm>
#include <string>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (11주 1)
//  
//
//-----------------------------------------------------------------

extern bool 관찰;



int main()	
{
	save("FileName.cpp");
	
	string s{ "1357924680" };
	
	
	sort(s.rbegin(), s.rend());
	cout << s << endl;
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 5:41:25 
====================================================================================================
#include <algorithm>
#include <string>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (11주 1)
//  
//
//-----------------------------------------------------------------

extern bool 관찰;



int main()	
{
	save("FileName.cpp");
	
	string s{ "1357924680" };
	
	
	sort(s.begin(), s.end());
	cout << s << endl;
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 6:23:03 
====================================================================================================
#include <algorithm>
#include <string>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (11주 1)
//  
//
//-----------------------------------------------------------------

extern bool 관찰;



int main()	
{
	save("FileName.cpp");
	
	String s{ "1357924680" };
	
	
	sort(s.begin(), s.end());
	cout << s << endl;
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 6:26:01 
====================================================================================================
#include <algorithm>
#include <string>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (11주 1)
//  
//
//-----------------------------------------------------------------

extern bool 관찰;



int main()	
{
	save("FileName.cpp");
	
	String s{ "1357924680" };
	
	
	sort(s.begin(), s.end(), [](char& s1, char& s2) {return s1 > s2; });
	cout << s << endl;
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 6:26:15 
====================================================================================================
#include <algorithm>
#include <string>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (11주 1)
//  
//
//-----------------------------------------------------------------

extern bool 관찰;



int main()	
{
	save("FileName.cpp");
	
	String s{ "1357924680" };
	
	
	sort(s.begin(), s.end(), [](char& a, char& b) {return a > b; });
	cout << s << endl;
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 6:26:41 
====================================================================================================
#include <algorithm>
#include <string>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (11주 1)
//  
//
//-----------------------------------------------------------------

extern bool 관찰;



int main()	
{
	save("FileName.cpp");
	
	String s{ "1357924680" };
	
	
	sort(s.begin(), s.end(), [](char a, char b) {return a > b; });
	cout << s << endl;
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 7:02:08 
====================================================================================================
#include <string>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (11주 1)
//  
// 알고리즘 함수는 반복자를 인자로 받는다
// 
//-----------------------------------------------------------------

extern bool 관찰;

//template<class 반복자,class 값>
//반복자 my_find(반복자 begin, 반복자 end, 값 val)
//{
//	return begin
//};

int main()	
{
	save("FileName.cpp");
	
	String s{ "20240513 - stl container iterator algorithm" };
	
	// 문제 사용자가 찾는 글자가 s에 있는지 알려주자

	while (1)
	{
		cout << "찾을 문자는?";
		char ch;
	/*	auto p = my_find(s.begin(), s.end(), ch);
		if (p != s.end())
			cout << "위치 - " << "을 찾음" << endl;
		else
			cout << ch << "는 s에 없는 글자입니다" << endl;*/
	}
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-14 화요일 오후 3:29:20 
====================================================================================================
#include <string>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (11주 1)
//  
// 알고리즘 함수는 반복자를 인자로 받는다
// 
//-----------------------------------------------------------------

extern bool 관찰;

template<class 반복자,class 값>
반복자 my_find(반복자 begin, 반복자 end, 값 val)
{
	return begin;
};

int main()	
{
	save("FileName.cpp");
	
	String s{ "20240513 - stl container iterator algorithm" };
	
	// 문제 사용자가 찾는 글자가 s에 있는지 알려주자

	while (1)
	{
		cout << "찾을 문자는?";
		char ch;
		auto p = my_find(s.begin(), s.end(), ch);
		if (p != s.end())
			cout << "위치 - " << "을 찾음" << endl;
		else
			cout << ch << "는 s에 없는 글자입니다" << endl;
	}
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-14 화요일 오후 3:32:56 
====================================================================================================
#include <string>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (11주 2)
//  
// 알고리즘 함수는 반복자를 인자로 받는다
// 6/11 화요일 기말 
//-----------------------------------------------------------------

extern bool 관찰;

template<class 반복자,class 값>
반복자 my_find(반복자 begin, 반복자 end, 값 val)
{
	return begin;
};

int main()	
{
	save("FileName.cpp");
	
	String s{ "20240513 - stl container iterator algorithm" };
	
	// 문제 사용자가 찾는 글자가 s에 있는지 알려주자

	while (1)
	{
		cout << "찾을 문자는?";
		char ch;
		cin >> ch;
		auto p = find(s.begin(), s.end(), ch);
		if (p != s.end())
			cout << "위치 - " << "을 찾음" << endl;
		else
			cout << ch << "는 s에 없는 글자입니다" << endl;

	}
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-14 화요일 오후 3:33:14 
====================================================================================================
#include <string>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (11주 2)
//  
// 알고리즘 함수는 반복자를 인자로 받는다
// 6/11 화요일 기말 
//-----------------------------------------------------------------

extern bool 관찰;

template<class 반복자,class 값>
반복자 my_find(반복자 begin, 반복자 end, 값 val)
{
	return begin;
};

int main()	
{
	save("FileName.cpp");
	
	String s{ "20240513 - stl container iterator algorithm" };
	
	// 문제 사용자가 찾는 글자가 s에 있는지 알려주자

	while (1)
	{
		cout << "찾을 문자는?";
		char ch;
		cin >> ch;
		auto p = find(s.begin(), s.end(), ch);
		if (p != s.end())
			cout << "위치 - " << ch << "을 찾음" << endl;
		else
			cout << ch << "는 s에 없는 글자입니다" << endl;

	}
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-14 화요일 오후 3:39:44 
====================================================================================================
#include <string>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (11주 2)
//  
// 알고리즘 함수는 반복자를 인자로 받는다
// 6/11 화요일 기말 
//-----------------------------------------------------------------

extern bool 관찰;

template<class 반복자,class 값>
반복자 my_find(반복자 begin, 반복자 end, 값 val)
{
	while (begin != end)
	{
		if (*begin == val)
			return begin;
		++begin;
	}
	return begin;
};

int main()	
{
	save("FileName.cpp");
	
	String s{ "20240513 - stl container iterator algorithm" };
	
	// 문제 사용자가 찾는 글자가 s에 있는지 알려주자

	while (1)
	{
		cout << "찾을 문자는?";
		char ch;
		cin >> ch;
		auto p = my_find(s.begin(), s.end(), ch);
		if (p != s.end())
			cout << "위치 - " << ch << "을 찾음" << endl;
		else
			cout << ch << "는 s에 없는 글자입니다" << endl;

	}
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-14 화요일 오후 3:43:09 
====================================================================================================
#include <string>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (11주 2)
//  
// 알고리즘 함수는 반복자를 인자로 받는다
// 6/11 화요일 기말 
//-----------------------------------------------------------------

extern bool 관찰;

template<class 반복자,class 값>
반복자 my_find(반복자 begin, 반복자 end, 값 val)
{
	while (begin != end)
	{
		if (*begin == val)
			return begin;
		++begin;
	}
	return begin;
};

int main()	
{
	save("FileName.cpp");
	
	String s{ "20240513 - stl container iterator algorithm" };
	
	// 문제 사용자가 찾는 글자가 s에 있는지 알려주자

	while (1)
	{
		cout << "찾을 문자는?";
		char ch;
		cin >> ch;
		auto p = my_find(s.begin(), s.end(), ch);
		if (p != s.end())
			cout << ch << "는 s의 " << distance(s.begin(), p) + 1 << "번째 문자입니다" << endl;
		else
			cout << ch << "는 s에 없는 글자입니다" << endl;
	}
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-14 화요일 오후 3:56:05 
====================================================================================================
#include <string>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (11주 2)
//  
// 알고리즘 함수는 반복자를 인자로 받는다
// 6/11 화요일 기말 
//-----------------------------------------------------------------

extern bool 관찰;

template<class 반복자,class 람다>
반복자 my_find_if(반복자 begin, 반복자 end, 람다 lamb)
{
	while (begin != end)
	{
		if (lamb(*begin))
			return begin;
		++begin;
	}
	return begin;
};

int main()	
{
	save("FileName.cpp");
	
	String s{ "stl container iterator algorithm - 2024년 5월 14일" };
	
	// 문제 사용자가 찾는 조건에 맞는 글자가 s에 있는지 알려주자

	
	auto p = my_find_if(s.begin(), s.end(), [](char c) {
		if (isdigit(c)) { if (c & 1)return true; }		return false; });	// c%2 보다 c&1이 더 좋다
	
	if (p != s.end())
		cout << *p << "는 s의 " << distance(s.begin(), p) + 1 << "번째 문자입니다" << endl;
	else
		cout <<  "s에 없는 글자입니다" << endl;

}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-14 화요일 오후 4:08:04 
====================================================================================================
#include <string>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (11주 2)
//  
// 알고리즘 함수는 반복자를 인자로 받는다
// 6/11 화요일 기말 
//-----------------------------------------------------------------

extern bool 관찰;

// 세번째 인자는 callable type인데 이 중에서 boolean 값을 리턴하는 것을 
// 특별히 predicate라고 부른다(조건자, 서술자, 판단자)

template<class 반복자,class 람다>
반복자 my_find_if(반복자 begin, 반복자 end, 람다 lamb)//반복자 my_find_if(반복자 begin, 반복자 end, 조건자 f)
{
	while (begin != end)
	{
		if (lamb(*begin))
			return begin;
		++begin;
	}
	return begin;
};

bool 홀수판단(char c)
{
	if (isdigit(c)) { if (c & 1)return true; }	
	return false;
}

int main()	
{
	save("FileName.cpp");
	
	String s{ "stl container iterator algorithm - 2024년 5월 14일" };
	
	// 문제 사용자가 찾는 조건에 맞는 글자가 s에 있는지 알려주자

	
	auto p = my_find_if(s.begin(), s.end(), 홀수판단);	// c%2 보다 c&1이 더 좋다
	
	if (p != s.end())
		cout << *p << "는 s의 " << distance(s.begin(), p) + 1 << "번째 문자입니다" << endl;
	else
		cout <<  "s에 없는 글자입니다" << endl;

}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-14 화요일 오후 4:33:35 
====================================================================================================
#include <string>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (11주 2)
//  
// 알고리즘 함수는 반복자를 인자로 받는다
// 6/11 화요일 기말 
//-----------------------------------------------------------------

extern bool 관찰;

// 세번째 인자는 callable type인데 이 중에서 boolean 값을 리턴하는 것을 
// 특별히 predicate라고 부른다(조건자, 서술자, 판단자)

template<class 반복자,class 람다>
반복자 my_find_if(반복자 begin, 반복자 end, 람다 lamb)//반복자 my_find_if(반복자 begin, 반복자 end, 조건자 f)
{
	
	while (begin != end)
	{
		if (lamb(*begin))
			return begin;
		++begin;
	}
	return begin;
};

bool 홀수판단(char c)
{
	if (isdigit(c)) { if (c & 1)return true; }	
	return false;
}

int main()	
{
	save("FileName.cpp");
	
	//String s{ "stl container iterator algorithm - 2024년 5월 14일" };
	String s{ "20240514 기말시험 6월 15일 15주 2일" };
	
	// 문제 s에 있는 홀수를 모두 찾아 출력하라

	auto beg = s.begin();
	while (1)
	{
		auto p = my_find_if(beg, s.end(), 홀수판단);	// c%2 보다 c&1이 더 좋다

		if (p != s.end())
			cout << *p << "는 s의 " << distance(s.begin(), p) + 1 << "번째 문자입니다" << endl;
		else
		{
			cout << "s에 없는 글자입니다" << endl;
			break;
		}
		beg = p + 1;
	}
	

}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-14 화요일 오후 4:46:22 
====================================================================================================
#include <string>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (11주 2)
//  
// 알고리즘 함수는 반복자를 인자로 받는다
// 6/11 화요일 기말 
//-----------------------------------------------------------------

extern bool 관찰;

// 세번째 인자는 callable type인데 이 중에서 boolean 값을 리턴하는 것을 
// 특별히 predicate라고 부른다(조건자, 서술자, 판단자)


template<class initer,class outiter>
void my_copy(initer begin, initer end, outiter d)
{
	while (begin != end)
	{
		*d = *begin;
		++begin;
		++d;
	}
}



int main()	
{
	save("FileName.cpp");
	
	
	String s{ "20240514 기말시험 6월 15일 15주 2일" };

	my_copy(s.begin(), s.end(), ostream_iterator<char>{cout});
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-14 화요일 오후 5:14:32 
====================================================================================================
#include <string>
#include <vector>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (11주 2)
//  
// Associative Conatainer - set
// 6/11 화요일 기말 
//-----------------------------------------------------------------

extern bool 관찰;

// 세번째 인자는 callable type인데 이 중에서 boolean 값을 리턴하는 것을 
// 특별히 predicate라고 부른다(조건자, 서술자, 판단자)


template<class initer,class outiter>
void my_copy(initer begin, initer end, outiter d)
{
	while (begin != end)
	{
		//*d operator=(*begin)
		*d = *begin;
		++begin;
		++d;
	}
}



int main()	
{
	save("FileName.cpp");
	
	
	String s{ "20240514 기말시험 6월 15일 15주 2일" };
	vector<char>v;

	my_copy(s.begin(), s.end(), back_inserter(v));	//undefind behavior

	for (char c : v)
		cout << c;
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 6:11:21 
====================================================================================================
#include <string>
#include <vector>
#include <set>
#include <fstream>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (11주 2)
//  
// Associative Conatainer - set
// set은 unique한 key 값을 정렬 상태로 유지한다
// uniqueness는 equivalence 관계를 이용하여 결정한다
// !(a>b)&&!(b>a) -> equivalence(동등한) 관계
// 비교해서 알아두자
// a==b -> equality(상등) 관계
//-----------------------------------------------------------------

extern bool 관찰;

// 세번째 인자는 callable type인데 이 중에서 boolean 값을 리턴하는 것을 
// 특별히 predicate라고 부른다(조건자, 서술자, 판단자)


template<class initer,class outiter>
void my_copy(initer begin, initer end, outiter d)
{
	while (begin != end)
	{
		//*d operator=(*begin)
		*d = *begin;
		++begin;
		++d;
	}
}



int main()	
{
	save("FileName.cpp");
	//문제 "이상한 나라의 앨리스.txt" 파일에 있는 단어를 set에 읽어와라

	set<String,std::less<String>> s;

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
		return 123456;
	
	
	s = { istream_iterator<String>{in}, {} };

	//String temp;
	//while (in >> temp)
	//	s.insert(temp);

	for (const String& t : s)
		cout << t << endl;
	cout << s.size() << endl;

	
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 6:45:00 
====================================================================================================
#include <string>
#include <vector>
#include <set>
#include <fstream>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (11주 2)
//  
// Associative Conatainer - set
// set은 어떻게 정렬하는가
// 디폴트 less<Key> - > operator<를 이용한다
// 
//-----------------------------------------------------------------

extern bool 관찰;





struct 람다 {
	bool operator()(const String& a, const String& b)const
	{
		//return a.getLen() < b.getLen();
		
		//대문자 먼저
		// 소 대 인경우만 변경하면 된다
		if (islower(*a.begin()) && isupper(*b.begin()))
			return false;
		else
			return true;
	}
};

//struct 람다
//{
//	bool operator()(const String& a, const String& b)	//predicate
//	{
//		return a.getLen() < b.getLen();
//	}
//};

bool comp(const String& a, const String& b)	//predicate
{
		return a.getLen() < b.getLen();
}

int main()	
{
	save("FileName.cpp");
	//문제 "이상한 나라의 앨리스.txt" 파일에 있는 단어를 set에 읽어와라
	//set은 단어길이기준 오름차순으로 정렬해야 한다
	//set은 대문자로 시작하는 단어가 먼저 나와야 한다


	multiset<String, 람다> s; //(*)==함수
	//set<String, bool(*)(const String&, const String&)> s{ comp }; //(*)==함수

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
		return 123456;
	
	
	s = { istream_iterator<String>{in}, {} };

	//String temp;
	//while (in >> temp)
	//	s.insert(temp);

	for (const String& t : s)
		cout << t << " ";
	cout << s.size() << endl;

	
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 6:46:05 
====================================================================================================
#include <string>
#include <vector>
#include <set>
#include <fstream>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (11주 2)
//  
// Associative Conatainer - set
// set은 어떻게 정렬하는가
// 디폴트 less<Key> - > operator<를 이용한다
// 
//-----------------------------------------------------------------

extern bool 관찰;






int main()	
{
	save("FileName.cpp");
	//문제 "이상한 나라의 앨리스.txt" 파일에 있는 단어를 mutiset에 읽어왔다
	

	multiset<String> s; //(*)==함수
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
		return 123456;
	
	
	s = { istream_iterator<String>{in}, {} };

	for (const String& t : s)
		cout << t << " ";
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 7:04:23 
====================================================================================================
#include <string>
#include <vector>
#include <set>
#include <fstream>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (11주 2)
//  
// Associative Conatainer - set
// set은 어떻게 정렬하는가
// 디폴트 less<Key> - > operator<를 이용한다
// 
//-----------------------------------------------------------------

extern bool 관찰;


bool 찾았다면(multiset<String> ms)
{

}


int main()	
{
	save("FileName.cpp");
	//문제 "이상한 나라의 앨리스.txt" 파일에 있는 단어를 mutiset에 읽어왔다
	

	multiset<String> s; //(*)==함수
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
		return 123456;
	
	
	s = { istream_iterator<String>{in}, {} };
	// 문제 찾는 단어가 set에 있는지 알려준다
	while (true)
	{
		cout << "찾을 단어는?";
		String word;
		cin >> word;

		if (s.find(word) != s.end())	//s.contains(word) 이 단어가 있는지 bool로 반환
			cout << word << "는 앨리스에 있는 단어입니다" << endl;
		else
			cout << "그런 단어 없습니다" << endl;
	}
	cout << s.size();
	
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-21 화요일 오후 4:09:23 
====================================================================================================
#include <string>
#include <vector>
#include <set>
#include <fstream>
#include <algorithm>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (12주 2)
//  
// Associative Conatainer - set
// set은 어떻게 정렬하는가
// 디폴트 less<Key> - > operator<를 이용한다
// 
//-----------------------------------------------------------------

extern bool 관찰;


bool 찾았다면(multiset<String> ms)
{

}


int main()	
{
	save("FileName.cpp");
	//문제 "이상한 나라의 앨리스.txt" 파일에 있는 단어를 mutiset에 읽어왔다
	

	multiset<String> s; //(*)==함수
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
		return 123456;
	
	
	s = { istream_iterator<String>{in}, {} };
	// 문제 찾는 단어가 일부라도 포함된 단어를 모두 출력하라
	// app -> apple
	while (true)
	{
		cout << "찾을 단어는?";
		String word;
		cin >> word;

		for (const String& s : s)
		{
			auto p = search(s.begin(), s.end(), word.begin(), word.end());
			if (p != s.end())
				cout << s << " ";
			// s는 word를 포함하고 있나?
		}
			
			
		

		
	}
	
	
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-21 화요일 오후 4:36:54 
====================================================================================================
#include <string>
#include <vector>
#include <set>
#include <fstream>
#include <algorithm>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (12주 2)
//  
// Associative Conatainer - set
// set은 어떻게 정렬하는가
// 디폴트 less<Key> - > operator<를 이용한다
// 
//-----------------------------------------------------------------

extern bool 관찰;


bool 찾았다면(multiset<String> ms)
{

}


int main()	
{
	save("FileName.cpp");
	//문제 "이상한 나라의 앨리스.txt" 파일에 있는 단어를 mutiset에 읽어왔다
	

	multiset<String> s; //(*)==함수
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
		return 123456;
	
	
	s = { istream_iterator<String>{in}, {} };
	// 문제 찾는 단어가 일부라도 포함된 단어를 모두 출력하라
	// app -> apple
	while (true)
	{
		cout << "찾을 단어는?";
		String word;
		cin >> word;

		set<String> F;
		for (const String& s : s)
		{
			// 문제 단어를 1개씩만 출력되게하라 - multiset을 바꾸지 마라
			auto p = search(s.begin(), s.end(), word.begin(), word.end());
			if (p != s.end() && !F.contains(s))
			{
				cout << s << " ";
				F.insert(s);
			}

			
				

			// s는 word를 포함하고 있나?
		}
			
			
		

		
	}
	
	
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-21 화요일 오후 4:53:30 
====================================================================================================
#include <string>
#include <vector>
#include <set>
#include <fstream>
#include <algorithm>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (12주 2)
//  
// Associative Conatainer - set
// set은 어떻게 정렬하는가
// 디폴트 less<Key> - > operator<를 이용한다
// 
//-----------------------------------------------------------------

extern bool 관찰;


bool 찾았다면(multiset<String> ms)
{

}


int main()	
{
	save("FileName.cpp");
	//문제 "이상한 나라의 앨리스.txt" 파일에 있는 단어를 mutiset에 읽어왔다
	
	//문제
	//1. 찾는 단어가 있니 y/n - contains
	//2. 찾는 단어가 있니 있으면 알려줘 - find
	//3. 찾는 단어가 있니 있으면 몇 개나 있니 - count(VS에서는 큰 문제가 없다 equal_range사용)
	//컴파일러와 무관하게 -> equal_range로 같은 일을 할 수 있다(operator ==이 필요없다)							   - count


	multiset<String> s; //(*)==함수
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
		return 123456;
	
	
	s = { istream_iterator<String>{in}, {} };
	// 문제 찾는 단어가 일부라도 포함된 단어를 모두 출력하라
	// app -> apple
	while (true)
	{
		cout << "찾을 단어는?";
		String word;
		cin >> word;
		size_t num = s.count(word);//count 는 연산자를 여러개 사용한다
		if (num)
			cout << word << " - " << num << "개 있다" << endl;
		else
			cout << "그런 단어 없습니다" << endl;
	}
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-21 화요일 오후 4:56:40 
====================================================================================================
#include <string>
#include <vector>
#include <set>
#include <fstream>
#include <algorithm>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (12주 2)
//  
// Associative Conatainer - set
// set은 어떻게 정렬하는가
// 디폴트 less<Key> - > operator<를 이용한다
// 
//-----------------------------------------------------------------

extern bool 관찰;


bool 찾았다면(multiset<String> ms)
{

}


int main()	
{
	save("FileName.cpp");
	//문제 "이상한 나라의 앨리스.txt" 파일에 있는 단어를 mutiset에 읽어왔다
	
	//문제
	//1. 찾는 단어가 있니 y/n - contains
	//2. 찾는 단어가 있니 있으면 알려줘 - find
	//3. 찾는 단어가 있니 있으면 몇 개나 있니 - count(VS에서는 큰 문제가 없다 equal_range사용)
	//컴파일러와 무관하게 -> equal_range로 같은 일을 할 수 있다(operator ==이 필요없다)							   - count


	multiset<String> s; //(*)==함수
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
		return 123456;
	
	
	s = { istream_iterator<String>{in}, {} };
	// 문제 찾는 단어가 일부라도 포함된 단어를 모두 출력하라
	// app -> apple
	while (true)
	{
		cout << "찾을 단어는?";
		String word;
		cin >> word;
		//구조화된 바인딩 structured-binding을 이용하여 값을 받는다
		auto [하한, 상한] = s.equal_range(word);  //[b,e)를 리턴

		if (하한 == 상한)
			cout << word << "- 없는 단어" << endl;
		else
			cout << distance(하한, 상한) << "개의 " << word << "발견" << endl;

	}
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-21 화요일 오후 5:22:35 
====================================================================================================
#include <string>
#include <list>
#include <map>
#include <fstream>
#include <algorithm>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (12주 2)
//  
// Associative Conatainer - map<key, value> -> dictionary
// map -> 연관배열처럼 사용할 수 있다 인덱스가 int가 아니다
// 
//-----------------------------------------------------------------

extern bool 관찰;




int main()	
{
	save("FileName.cpp");
	// 그룹과 멤버
	map<String, list<String>> m{ {"아이브",{"안유진","가을","레이","장원영","리즈","이서"}} };

	m.insert(pair<String, list<String>>{"블랙핑크", { "지수","제니","로제","리사" }});
	m.insert(make_pair("아이유", list<String>{"아이유"}));
	m["르세라핌"] = { "사쿠라","김채원","허윤진","카즈하","홍은채"};

	//전체 출력

	for (const auto& [그룹, 멤버] : m)
	{
		cout << 그룹 << " - " << 멤버.size() << "명 ";
		for (const auto& a : 멤버)
			cout << a << " ";
		cout << endl;
	}
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-27 월요일 오후 5:34:18 
====================================================================================================
#include <string>
#include <list>
#include <map>
#include <fstream>
#include <algorithm>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (13주 1)
//  
// Associative Conatainer - map<key, value> -> dictionary
// map -> 연관배열처럼 사용할 수 있다 인덱스가 int가 아니다
// 
//-----------------------------------------------------------------

extern bool 관찰;




int main()	
{
	save("FileName.cpp");
	//문제 "이상한 나라의 앨리스.txt"파일을 한 번 읽어서 
	//소문자와 출현횟수를 다음과 같이 출력하라
	// a - 333
	// b - 444
	// ..  z - 10


	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
		return 12345;
	char c;
	map<char, int> m;
	while (in >> c)
	{
		if (isalpha(c))
			m[tolower(c)]++;
	}

	for (auto [소문자, 개수] : m)
		cout << 소문자 << " - " << 개수 << endl;





}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-27 월요일 오후 5:52:43 
====================================================================================================
#include <string>
#include <ranges>
#include <list>
#include <map>
#include <fstream>
#include <algorithm>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (13주 1)
//  
// Associative Conatainer - map<key, value> -> dictionary
// map -> 연관배열처럼 사용할 수 있다 인덱스가 int가 아니다
// 
//-----------------------------------------------------------------

extern bool 관찰;




int main()	
{
	save("FileName.cpp");
	//문제 "이상한 나라의 앨리스.txt"파일을 한 번 읽어서 
	//소문자와 출현횟수를 다음과 같이 출력하라
	// a - 333
	// b - 444
	// ..  z - 10


	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
		return 12345;
	char c;
	map<char, int> m;
	while (in >> c)
	{
		if (isalpha(c))
			m[tolower(c)]++;
	}

	for (auto [소문자, 개수] : m)
		cout << 소문자 << " - " << 개수 << endl;

	//문제 개수 내림차순으로 출력하라

	//map<int, char, greater<int>> icm;
	map<int, char> icm;
	for (auto [소문자, 개수] : m)
		icm[개수] = 소문자;

	cout << "개수 기준으로 정렬" << endl;

	for (auto [개수, 소문자] : icm | views::reverse)	//#include ranges
		cout << 소문자 << " - " << 개수 << endl;

	//for (auto p = icm.rbegin(); p != icm.rend(); ++p)
	//	cout << p->second << " - " << p->first << endl;

	//for (auto [개수, 소문자] : icm)
	//	cout << 소문자 << " - " << 개수 << endl;

}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-27 월요일 오후 6:12:41 
====================================================================================================
#include <string>
#include <ranges>
#include <list>
#include <map>
#include <fstream>
#include <algorithm>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (13주 1)
//  
// Associative Conatainer - map<key, value> -> dictionary
// map -> 연관배열처럼 사용할 수 있다 인덱스가 int가 아니다
// 
//-----------------------------------------------------------------

extern bool 관찰;




int main()	
{
	save("FileName.cpp");
	//문제 "이상한 나라의 앨리스.txt"파일을 한 번 읽어서 
	//단어와 출현횟수를 출력하라



	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
		return 12345;
	String s;
	map<String, int> Sim;
	

	while (in >> s)
	{
		Sim[s]++;
	}

	

	//map<int, vector<String>> iSm;
	//for (const auto& [단어, 개수] : Sim)
	//	iSm[개수].push_back(단어);


	//for (const auto& [개수, 단어] : iSm | views::reverse)
	//	for(const String& s:단어)
	//		cout << s << " - " << 개수 << endl;

	multimap<int, String> iSm;
	for (const auto& [단어, 개수] : Sim)
		iSm.insert(make_pair(개수, 단어));


	for (const auto& [개수, 단어] : iSm | views::reverse | views::take(200))
			cout << 단어 << " - " << 개수 << endl;



	//문제 많이 사용된 단어 순으로 출력하라
	
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-27 월요일 오후 6:33:41 
====================================================================================================
#include <map>
#include <fstream>
#include <random>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (13주 1)
//  
// Associative Conatainer - map<key, value> -> dictionary
// map -> 연관배열처럼 사용할 수 있다 인덱스가 int가 아니다
// 
//-----------------------------------------------------------------

extern bool 관찰;

default_random_engine dre;
uniform_int_distribution uid{1,99999};


int main()	
{
	save("FileName.cpp");


	//유니폼분포는 정말 유니폼한가?
	//값을 10등분해서 출력횟수를 출력하라



	map<int, int> m;

	for (int i = 0; i < 1000000; ++i)
		m[uid(dre) / 10000]++;


	
	for (auto [구간, 개수] : m)
		cout << 구간 << " - " << 개수 << endl;
	





}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-27 월요일 오후 6:55:20 
====================================================================================================
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <fstream>
#include <random>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (13주 1)
//  
// unordered associative container
// unordered의 의미
// 메모리 구조 어떻게?
// 내가 만든 String도 관리가능해?
//-----------------------------------------------------------------

extern bool 관찰;

default_random_engine dre;
uniform_int_distribution uid{1,99999};
normal_distribution nd{ 0.0,0.1 };

int main()	
{
	save("FileName.cpp");


	//노말분포는 정말 노말한가?
	//값을 20등분해서 출력횟수를 출력하라



	map<int, int> m;

	for (int i = 0; i < 100000; ++i)
	{
		double val = nd(dre) * 50000 + 50000;
		if (0 < val && val < 100000)
			m[val / 5000]++;
	}
	
		


	
	for (auto [구간, 개수] : m)
		cout << 구간 << " - " << 개수 << endl;
	





}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-28 화요일 오후 4:02:33 
====================================================================================================
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <fstream>
#include <random>
#include <print>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (13주 1)
//  
// unordered associative container
// unordered의 의미
// 메모리 구조 어떻게?
// 내가 만든 String도 관리가능해?
//-----------------------------------------------------------------

extern bool 관찰;

default_random_engine dre;
uniform_int_distribution uid{1,99999};
normal_distribution nd{ 0.0,0.1 };

struct 해시 {
	size_t operator()(const String& s) const{
		return 7;
	}
};


void print_us(const unordered_multiset<String,해시>& us)
{
	for (int i = 0; i < us.bucket_count(); ++i)
	{
		print("[{:3}] ", i);
		for (auto p = us.begin(i); p != us.end(i); ++p)
			cout << " - " << *p;
		cout << endl;
	}
}


int main()	
{
	save("FileName.cpp");


	unordered_multiset<String,해시> us{"2024년","5월","28일","재미있는STL"};



	while (1)
	{
		cout << endl;
		print_us(us);
		cout << endl;

		cout << "추가할 데이터?";
		String s;
		cin >> s;
		us.insert(s);
	}

}                


====================================================================================================
FileName.cpp, 저장시간: 2024-05-28 화요일 오후 5:11:47 
====================================================================================================
#include <array>
#include <vector>
#include <set>
#include <unordered_set>
#include <algorithm>
#include <random>
#include <chrono>
#include <fstream>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (13주 2)
//  
// 컨테이너의 찾기 성능 비교 - 1000만개에서 10만개를 찾아본다
// 0. 벡터	105428ms 63170
// 1. 정렬한 벡터	24ms 63170		// 캐시 미스가 안일어남, random_access가 가능해서 접근시간이 항상 동일하다	->flat-set
// 2. set	77ms 63170
// 3. unordered set	3ms 63170
//-----------------------------------------------------------------

extern bool 관찰;


const int NUM = 10000000;
const int FNUM = 100000;
array<int, NUM>a;
array<int, FNUM>fa;

default_random_engine dre;
uniform_int_distribution uid{ 1,NUM };






int main()	
{
	save("FileName.cpp");
	for (int& num : a)
		num = uid(dre);

	for (int& num : fa)
		num = uid(dre);

	//{
	//	//벡터에서 찾기
	//	cout << "벡터 준비중...";
	//	vector<int> v{ a.begin(),a.end() };
	//	cout << endl;
	//	int count{};

	//	auto start = chrono::high_resolution_clock::now();
	//	for (int num : fa)
	//	{
	//		auto p =find(v.begin(), v.end(), num);
	//		if (p != v.end())
	//			++count;
	//	}
	//	auto end = chrono::high_resolution_clock::now();
	//	auto elapsed = end - start;	// duration
	//	auto 걸린시간 = chrono::duration_cast<chrono::milliseconds>(elapsed);
	//	cout << "걸린시간 - " << 걸린시간 << endl;
	//	cout << FNUM << "에서 " << count << "개를 찾음" << endl;
	//	cout << endl;
	//}	



	//{
	//	//셋에서 찾기
	//	cout << "셋 준비중...";
	//	multiset<int> s{ a.begin(),a.end() };
	//	cout << endl;
	//	int count{};

	//	auto start = chrono::high_resolution_clock::now();
	//	for (int num : fa)
	//	{
	//		if (s.contains(num))
	//			++count;
	//	}
	//	auto end = chrono::high_resolution_clock::now();
	//	auto elapsed = end - start;	// duration
	//	auto 걸린시간 = chrono::duration_cast<chrono::milliseconds>(elapsed);
	//	cout << "걸린시간 - " << 걸린시간 << endl;
	//	cout << FNUM << "에서 " << count << "개를 찾음" << endl;
	//	cout << endl;
	//}

	//{
	//	//언오더 셋에서 찾기
	//	cout << "언오더 멀티셋 준비중...";
	//	unordered_multiset<int> us;
	//	us.reserve(NUM);
	//	us = { a.begin(),a.end() };
	//	cout << endl;
	//	int count{};

	//	auto start = chrono::high_resolution_clock::now();
	//	for (int num : fa)
	//	{
	//		if (us.contains(num))
	//			++count;
	//	}
	//	auto end = chrono::high_resolution_clock::now();
	//	auto elapsed = end - start;	// duration
	//	auto 걸린시간 = chrono::duration_cast<chrono::milliseconds>(elapsed);
	//	cout << "걸린시간 - " << 걸린시간 << endl;
	//	cout << FNUM << "에서 " << count << "개를 찾음" << endl;
	//	cout << endl;
	//}


	{
		//정렬한 벡터에서 찾기
		cout << "정렬한 벡터 준비중...";
		vector<int> v;
		v.reserve(NUM);
		v = { a.begin(), a.end() };

		sort(v.begin(), v.end());
		cout << endl;
		int count{};

		auto start = chrono::high_resolution_clock::now();
		for (int num : fa)
		{
			if (binary_search(v.begin(), v.end(), num))
				++count;
		}
		auto end = chrono::high_resolution_clock::now();
		auto elapsed = end - start;	// duration
		auto 걸린시간 = chrono::duration_cast<chrono::milliseconds>(elapsed);
		cout << "걸린시간 - " << 걸린시간 << endl;
		cout << FNUM << "에서 " << count << "개를 찾음" << endl;
		cout << endl;
	}	
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-06-03 월요일 오후 6:01:46 
====================================================================================================
#include <array>
#include <algorithm>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (14주 1)
//  
// 
//-----------------------------------------------------------------

extern bool 관찰;

template <class 반복자, class 단항조건자>
bool my_all_of(반복자 b, 반복자 e, 단항조건자 p)
{
	while (b != e)
	{
		if (not p(*b))
			return false;
		++b;
	}
	return true;
}

int main()	
{
	save("FileName.cpp");
	array<int, 0> a;
	//문제 a의 원소가 모두 홀수인가? 검사하고 출력하자
	
	bool b = my_all_of(a.begin(), a.end(), [](int n) {return n & 1; });
	if (b)
		cout << "홀수가 아닌것은 한개도 없다" << endl;
	else
		cout << "모두가 홀수인것은 아니다" << endl;

}                


====================================================================================================
FileName.cpp, 저장시간: 2024-06-03 월요일 오후 6:09:18 
====================================================================================================
#include <array>
#include <algorithm>
#include <numeric>
#include <random>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (14주 1)
//  
// 
//-----------------------------------------------------------------

extern bool 관찰;

default_random_engine dre{ random_device{}() };


int main()	
{
	save("FileName.cpp");
	

	// [1,46) 숫자,이 중에 6개를 뽑아라
	array<int, 45> a;
	iota(a.begin(), a.end(), 1);

	cout << "이번주 번호" << endl;
	sample(a.begin(), a.end(), ostream_iterator<int>{cout, " "}, 6, dre);
	

}                


====================================================================================================
FileName.cpp, 저장시간: 2024-06-03 월요일 오후 6:20:22 
====================================================================================================
#include <array>
#include <algorithm>
#include <numeric>
#include <print>
#include <thread>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (14주 1)
//  
// sort 관련 algorithm
//-----------------------------------------------------------------

extern bool 관찰;



int main()	
{
	save("FileName.cpp");
	
	//문제
	string s{ "STL - Container - iterator - Algorithm" };
	for (int i = 0; i < 10; ++i)
		cout << endl;
	
	while (1)
	{
		rotate(s.begin(), s.end()- 1, s.end());
		print("{:^80}", s);
		cout << "\r";
		this_thread::sleep_for(100ms);
	}
	
}                


====================================================================================================
FileName.cpp, 저장시간: 2024-06-03 월요일 오후 6:47:19 
====================================================================================================
#include <array>
#include <algorithm>
#include <numeric>
#include <print>
#include <thread>
#include <random>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (14주 1)
//  
// sort 관련 algorithm - 복잡도
// partition
// nth_element
// partial_sort
// sort
// stable_sort
//-----------------------------------------------------------------

extern bool 관찰;

random_device rd;
default_random_engine dre{ rd() };
uniform_int_distribution<int> uidC{ 'A','Z' };
uniform_int_distribution uidN{ 1,30 };

int main()
{
	save("FileName.cpp");

	array<int, 100> a;
	iota(a.begin(), a.end(), 1);
	{
		// 홀짝으로 분리 -  partiotion
		cout << "홀짝으로 분리하기 전" << endl;
		shuffle(a.begin(), a.end(), dre);
		for (int num : a)
			print("{:4}", num);
		
		auto p = partition(a.begin(), a.end(), [](int n) {return n & 1; });

		cout << endl;
		cout << "홀수" << endl;
		for (auto i = a.begin(); i != p; ++i)
			print("{:4}", *i);

		cout << endl;
		cout << "짝수" << endl;
		for (auto i = p; i != a.end(); ++i)
			print("{:4}", *i);
	}
	cout << endl;
	cout << endl;
	{
		// 30등까지와 나머지로 분리 -  nth_element
		cout << "30등까지와 나머지로 분리하기 전" << endl;
		shuffle(a.begin(), a.end(), dre);
		for (int num : a)
			print("{:4}", num);

		nth_element(a.begin(), a.begin() + 30, a.end());
		auto nth = a.begin() + 30;

		cout << endl;
		cout << "30등까지" << endl;
		for (auto i = a.begin(); i != nth; ++i)
			print("{:4}", *i);

		cout << endl;
		cout << "나머지" << endl;
		for (auto i = nth; i != a.end(); ++i)
			print("{:4}", *i);
	}

	cout << endl;
	cout << endl;
	{
		// 30등까지만 정렬 -  partial_sort
		cout << "30등까지와 나머지로 분리하기 전" << endl;
		shuffle(a.begin(), a.end(), dre);
		for (int num : a)
			print("{:4}", num);

		partial_sort(a.begin(), a.begin() + 30, a.end());
		auto nth = a.begin() + 30;

		cout << endl;
		cout << "30등까지" << endl;
		for (auto i = a.begin(); i != nth; ++i)
			print("{:4}", *i);

		cout << endl;
		cout << "나머지" << endl;
		for (auto i = nth; i != a.end(); ++i)
			print("{:4}", *i);
	}

	
}


====================================================================================================
FileName.cpp, 저장시간: 2024-06-03 월요일 오후 7:04:01 
====================================================================================================
#include <array>
#include <algorithm>
#include <numeric>
#include <print>
#include <thread>
#include <random>
#include <ranges>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (14주 1)
//  
// sort 관련 algorithm - 복잡도
// partition
// nth_element
// partial_sort
// sort
// stable_sort
//-----------------------------------------------------------------

extern bool 관찰;

random_device rd;
default_random_engine dre{ rd() };
uniform_int_distribution<int> uidC{ 'A','Z' };
uniform_int_distribution uidN{ 1,30 };

int main()
{
	save("FileName.cpp");

	struct Dog
	{
		char c = uidC(dre);
		int n{ uidN(dre) };
	};

	array<Dog, 100> dogs;

	//문제 dogs를 글자 오름차순으로 정렬


	//sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {return a.c < b.c; });
	ranges::sort(dogs, {}, & Dog::c);
	ranges::stable_sort(dogs, {}, & Dog::n);	//동등한 것들의 순서가 유지된다

	cout << endl;
	for (auto [글자, 숫자] : dogs)
		cout << "\t" << 글자 << " - " << 숫자 << endl;;
	
}


====================================================================================================
FileName.cpp, 저장시간: 2024-06-04 화요일 오후 4:41:44 
====================================================================================================
#include <array>
#include <algorithm>
#include <vector>
#include <list>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (14주 2)
//  
// 반복자간의 거리를 재는 distance 함수를 잘 알아본다
// c++20 concept / range
//-----------------------------------------------------------------

extern bool 관찰;


template <class 반복자>

long long my_distance(반복자 b, 반복자 e)
{
	//만일 random access 반복자라면
	// return e-b
	//아니라면
	//if (typeid(iterator_traits<반복자>::iterator_category).name() == typeid(random_access_iterator_tag).name())
	//if (is_same<typename iterator_traits<반복자>::iterator_category, random_access_iterator_tag>::value)

	// c++17부터는 constexpr if로 선택적 소스코드확장 가능
	if constexpr(is_same_v<typename iterator_traits<반복자>::iterator_category, random_access_iterator_tag>)
		return e - b;

	long long dis = 0;
	while (b != e)
	{
		++b;
		++dis;
	}
	return dis;
}


int main()
{
	save("FileName.cpp");
	list<int> v{ 1,2,3,4,5 };
  	
	
	auto p = v.begin();
	--p;
	if (p == v.end())
		cout << "이중연결리스트";
	//distance 함수로 반복자간의 거리를 잰다

	cout << my_distance(v.end(), v.begin()) << endl;
}


====================================================================================================
FileName.cpp, 저장시간: 2024-06-04 화요일 오후 4:52:44 
====================================================================================================
#include <array>
#include <algorithm>
#include <vector>
#include <list>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (14주 2)
//  
// 반복자간의 거리를 재는 distance 함수를 잘 알아본다
// c++20 concept / range
//-----------------------------------------------------------------

extern bool 관찰;



template<class T>

T add(T a, T b)
{
	return a + b;
}


int main()
{
	//문제 함수 템플릿 add를 만들어라
	save("FileName.cpp");
	cout << add(1, 2) << endl;
	cout << add(1.1, 2.2) << endl;
	cout << add("2024년"s, "6월4일"s) << endl;		//템플릿에게 의도를 전달해줘야 한다
}


====================================================================================================
FileName.cpp, 저장시간: 2024-06-04 화요일 오후 4:59:37 
====================================================================================================
#include <array>
#include <algorithm>
#include <vector>
#include <list>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (14주 2)
//  
// 반복자간의 거리를 재는 distance 함수를 잘 알아본다
// c++20 concept / range
//-----------------------------------------------------------------

extern bool 관찰;



template<class T>
concept 숫자만 = is_integral_v<T> or is_floating_point_v<T>;

template<숫자만 T>
T add(T a, T b)
{
	return a + b;
}


int main()
{
	//문제 함수 템플릿 add를 만들어라
	save("FileName.cpp");
	cout << add(1, 2) << endl;
	cout << add(1.1, 2.2) << endl;
	//cout << add("2024년", "6월4일") << endl;		//템플릿에게 의도를 전달해줘야 한다
}


====================================================================================================
FileName.cpp, 저장시간: 2024-06-04 화요일 오후 5:20:36 
====================================================================================================
#include <array>
#include <algorithm>
#include <vector>
#include <list>
#include <ranges>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (14주 2)
//  
// 반복자간의 거리를 재는 distance 함수를 잘 알아본다
// c++20 concept / range
//-----------------------------------------------------------------

extern bool 관찰;



template<class T>
concept 숫자만 = is_integral_v<T> or is_floating_point_v<T>;

template<숫자만 T>
T add(T a, T b)
{
	return a + b;
}


int main()
{
	//문제 함수 템플릿 add를 만들어라
	save("FileName.cpp");
	list<int> list{ 1,2,3 };
	//ranges::sort(list.begin(),list.end();

}


====================================================================================================
FileName.cpp, 저장시간: 2024-06-10 월요일 오후 5:45:54 
====================================================================================================
#include <array>
#include <algorithm>
#include <vector>
#include <random>
#include <numeric>
#include <print>
#include <list>
#include <ranges>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (15주 1)
//  
// c++20 range
// - [begin, end)
// - begin + size
// - [begin, predicate)
// - [begin, ...)   무한
//-----------------------------------------------------------------

extern bool 관찰;

default_random_engine dre;

template<class T>
concept 숫자만 = is_integral_v<T> or is_floating_point_v<T>;

template<숫자만 T>
T add(T a, T b)
{
	return a + b;
}


int main()
{
	save("FileName.cpp");

	vector<int> v(100);

	//ranges::iota(v.begin(),v.end(), 1);
	ranges::iota(v, 1);		// constrained-algorithm
							// c++20 concept으로 작성한 함수

	ranges::shuffle(v, dre);

	ranges::sort(v);
		
	for (int num : views::counted(v.begin(), 20))
		cout << num << endl;

}


====================================================================================================
FileName.cpp, 저장시간: 2024-06-10 월요일 오후 5:50:28 
====================================================================================================
#include <array>
#include <algorithm>
#include <vector>
#include <random>
#include <numeric>
#include <print>
#include <list>
#include <ranges>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (15주 1)
//  
// c++20 range
// - [begin, end)
// - begin + size
// - [begin, predicate)
// - [begin, ...)   무한
//-----------------------------------------------------------------

extern bool 관찰;

default_random_engine dre;

template<class T>
concept 숫자만 = is_integral_v<T> or is_floating_point_v<T>;

template<숫자만 T>
T add(T a, T b)
{
	return a + b;
}


int main()
{
	save("FileName.cpp");

	vector<int> v(100);

	//ranges::iota(v.begin(),v.end(), 1);
	ranges::iota(v, 1);		// constrained-algorithm
							// c++20 concept으로 작성한 함수

	ranges::shuffle(v, dre);

	ranges::sort(v.begin(),v.begin()+20);
		
	for (int num : views::filter(v, [](int n) {return n & 1; }))
		cout << num << endl;

}


====================================================================================================
FileName.cpp, 저장시간: 2024-06-10 월요일 오후 6:22:13 
====================================================================================================
#include <array>
#include <algorithm>
#include <vector>
#include <random>
#include <numeric>
#include <print>
#include <list>
#include <ranges>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (15주 1)
//  
// c++20 range
// - [begin, end)
// - begin + size
// - [begin, predicate)
// - [begin, ...)   무한
//-----------------------------------------------------------------

extern bool 관찰;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uid{ 1,100 };


// c++20 ranges 라이브러리
// 기존 알고리즘을 다 새로 작성함
// -c++20 concept을 사용하여 인자를 제약하였다
// -Projection 과 pointer to member를 사용할 수 있다
// -더 풍부한 정보를 담는 return 값 제공


struct Dog
{
	char c = uidC(dre);
	int n{ uid(dre) };
};


int main()
{
	save("FileName.cpp");

	vector<Dog> dogs(100);

	// 두 번째 인자 {} -> 디폴트 정렬기준 -> less<>
	// less <-> greater
	ranges::sort(dogs, greater<char>{}, & Dog::c);


	for (auto [글자, 숫자] : dogs)
		cout << 글자 << " - " << 숫자 << endl;


}


====================================================================================================
FileName.cpp, 저장시간: 2024-06-10 월요일 오후 6:30:19 
====================================================================================================
#include <array>
#include <algorithm>
#include <vector>
#include <random>
#include <numeric>
#include <print>
#include <list>
#include <ranges>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (15주 1)
//  
// c++20 range
// - [begin, end)
// - begin + size
// - [begin, predicate)
// - [begin, ...)   무한
//-----------------------------------------------------------------

extern bool 관찰;




int main()
{
	save("FileName.cpp");

	// 소수(prime number)를 출력하라


	for (int num : ranges::views::iota(1) | views::drop(100) | views::take(1000) | views::reverse | views::filter([](int n) {return n & 1; }))
		print("{} ", num);

}


====================================================================================================
FileName.cpp, 저장시간: 2024-06-10 월요일 오후 6:41:23 
====================================================================================================
#include <array>
#include <algorithm>
#include <vector>
#include <random>
#include <numeric>
#include <print>
#include <list>
#include <ranges>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (15주 1)
//  
// c++20 range
// - [begin, end)
// - begin + size
// - [begin, predicate)
// - [begin, ...)   무한
//-----------------------------------------------------------------

extern bool 관찰;



int main()
{
	save("FileName.cpp");

	// 100000 보다 큰 소수(prime number)를 출력하라

	auto 소수 = [](int n)
		{
			if (n <= 1)
				return false;

			for (int i = 2; i < n; i++) {

				if (n % i == 0)
				{//i가 n의 약수라면 소수가 아니므로 false return
					return false;
				}
			}
			//2 ~ n-1까지 약수가 없다면 소수이므로, true return
			return true;
		};


	for (int num : ranges::views::iota(100000) | views::filter(소수) | views::take(100) | views::reverse)
		print("{} ", num);

}


====================================================================================================
FileName.cpp, 저장시간: 2024-06-10 월요일 오후 7:08:08 
====================================================================================================
#include <array>
#include <algorithm>
#include <vector>
#include <random>
#include <numeric>
#include <print>
#include <list>
#include <ranges>
#include "String.h"
#include "save.h"

//-----------------------------------------------------------------
// 2024.04.30 1학기 stl				                        (15주 1)
//  
// c++20 range
// - [begin, end)
// - begin + size
// - [begin, predicate)
// - [begin, ...)   무한
//-----------------------------------------------------------------

extern bool 관찰;



int main()
{
	save("FileName.cpp");

	vector<int>v;

	// ADL(argument dependent lookup) 기능이 작동하지 않도록
	// Eric Niebler
	find(v.begin(), v.end(), 3);
	ranges::find(v.begin(), v.end(), 3);


}